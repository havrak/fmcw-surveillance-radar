\def\PageLayout{single-no-print}
\def\DocLanguage{en}
\def\PackagesIncludeTikz{yes}
\def\PackagesIncludeBib{yes}

\input{dimensions_paper}
\input{packages}
\input{metadata}
\input{macros}
\input{xmp}
\input{doc_paper}

\newcommand{\sidar}{SiRad Easy\textsuperscript{\copyright}}

\addbibresource{bibliography.bib}

\begin{document}

\include{doc_paper_title_page_en}

\tableofcontents

\newpage
\pagenumbering{arabic}
\setcounter{page}{1}

\include{introduction}
\pagestyle{fancy}


\chapter{Design parameters}

First of all it is necessary to outline basic requirements we have for the platform.

\section{Physical capabilities}

Main design limitations on physical design stem from radiation pattern of radar (24 and 122 GHz header) used as we want to prevent strong reflections from the structure.
According to 122 GHz Transceiver datasheet angular width (-3dB) is roughly $\pm30\text{°}$\cite{sidarTRX} both in E plane and H plane.
With addition of radar dome this values comes down to $\pm4\text{°}$ \cite{sidarMAN}.
The radiation pattern of for 24GHz micropatch antenna was not listed by the manufacturer but we can assume it is similar to other products.
Conservative estimate of $\pm15\text{°}$ based on designs \cite{patch1} and \cite{patch2} is used.
According to these values we can set rather forgiving limits -- $\pm45\text{°}$ of clearance in front of the radar.


Due to relatively low polling rate of radar system (1Mbit/s) highspeed movement is not necessary.
Advertised maximal update frequency from manufacturer is  50Hz (new update every 20ms) \cite{sidarMAN}.
From following equation
%
\begin{equation}
  t_{\mathrm{angle}} = \frac{60}{360\cdot N_{\mathrm{RMP}}} \cdot  \alpha,
  \label{eq:poll}
\end{equation}
%
where $t_{\mathrm{angle}}$ is time between spend on traveling angle of $\alpha $ in seconds and $N_{\mathrm{RMP}}$ is number of rotations per minute, we can calculate that even for low RPM of 60 the angle of 8° (angular width of main lobe for 122 GHz radar) is traveled in 10ms - two times faster then we are receiving data.






% cite manual of the radar board for radiation pattern, maybe look up some existing solutions

\section{Software requirements}

Since G-code is widely used industry standard for controlling most multi-axis machines it is natural choice for our platform.
Aside from basic functionality found in many G-code interpreters we need to provide some additional capabilities to not overburden the user with manual control.
These include ability to set limits on movement or being able to preprogram movements which the platform will then execute on its own.


In terms of uplink user needs to know current position of the platform and have information about its current speed in order to make mathematical correction to the data gathered by radar.
Since the platform is not concerned with what antenna is currently used calculating speed of the radar itself is not possible as different antennas wile have different angular speeds on the tilt axis.
Thus the platform needs to provide information about its current position in relatively frequent intervals in order to enable an accurate calculation of speed in MATLAB.




\chapter{Hardware construction}

As we need to facilitate continuos rotating motion use of slipring was absolutely necessary.
Due to relatively low transmission speeds of radar system (At max 1Mbit/s) standard contact slipring is sufficient.
Rest of the structure can be 3D printed from PLA as the mechanical stress on the structure is relatively low.

\begin{figure}[h!]
  \centering
  \begin{subfigure}[b]{0.45\textwidth}
    \centering
    \includegraphics[width=\textwidth]{../img/whole_assembly_2.png} % Replace with your image path
    \caption{3D render}
  \end{subfigure}
  \hspace{0.05\textwidth} % Adjust spacing
  \begin{subfigure}[b]{0.45\textwidth}
    \centering
    \includegraphics[width=0.75\textwidth]{../img/assembly_photo.jpg} % Replace with your image path
    \caption{Photo}
  \end{subfigure}
  \caption{Form of the final assembly}
  \label{fig:side_by_side}
\end{figure}

\section{Electronics}

Electronic side of the project is rather simple as we only need to control two stepper motors and have way to home them.
Whole system is controlled by ESP32 microcontroller since project doesn't require any special capabilities basic series of ESP32 microcontrollers is sufficient.

As the load on stepper motors is relatively low and whole platform will not be able to accumulate large amount of momentum simple stepper driver without feedback control is sufficient.
For this project A4988 stepper driver was chosen as it is cheap, easy to use and offers basic current control to smooth out stepper movement\cite{a4988}.

For homing  there were two prospective solutions -- Hall effect sensors, optical gates.
While Hall effect would offer sensing of any angle and thus be able to combat any drift in position during operation its integration would be rather complex.
As if orthogonal Hall effect sensors isn't placed exactly in axis of rotation calibration of the system is required\cite{hall}.
Thus for simplicity and ease of integration optical gates were chosen.


\chapter{Software realization}

In order to achieve maximal efficiency in processing commands and  maintain accurate driving of stepper motors workflow of the program is split into three distinct layers, as showed on diagram \ref{fig:code_diag}.
Using standard two component architecture with one part handling the parsing of commands and second managing their execution wasn't for this usecase - pre programming movements wouldn't be possible and precomputing multiple movements ahead unnecessary hard.
Now with increasing layer the amount of abstraction in command decreases and processing gets easier.
This enables the final stage to be really efficient thus moving form one command to another is more restricted by inertia of stepper motors.

\begin{figure}[h!]
  \centering


  \begin{tikzpicture}[scale=0.9, node distance=1.5cm]

    % Layer headers
    \node (comm_layer) [layerheader] at (0, 0) {Communication Layer};
    \node (app_layer) [layerheader] at (6, 0) {Application Layer};
    \node (hal_layer) [layerheader] at (12, 0) {HAL Layer};

    % Communication Layer
    \node (comm_start) [startstop, below of=comm_layer, yshift=-0.3cm] {Start};
    \node (wait_serial) [process, below of=comm_start] {Wait for serial data};
    \node (parse_gcode) [process, below of=wait_serial] {Parse G-code};
    \node (parse_success) [decision, below of=parse_gcode, align=center, yshift=-1.3cm] {Parsing\\ Successful?};
    \node (store_command) [process, below of=parse_success, align=center, yshift=-1.8cm] {Store command\\ queue ? program};
    \node (send_response) [process, below of=store_command,yshift=-0.25cm] {Send response};

    % Arrows in Communication Layer
    \draw [arrow] (comm_start) -- (wait_serial);
    \draw [arrow] (wait_serial) -- (parse_gcode);
    \draw [arrow] (parse_gcode) -- (parse_success);
    \draw [arrow] (parse_success.east) -- ++(1, 0) |- (send_response.east) node[midway, left, yshift=+0.25cm] {No};
    \draw [arrow] (parse_success.south) -- ++(0, -0.5) -| (store_command.north) node[midway, right, yshift=+0.05cm] {Yes};
    \draw [arrow] (store_command) -- (send_response);
    \draw [arrow] (send_response.west) -- ++(-0.5, 0) |- (wait_serial.west);

    % Application Layer
    \node (app_start) [startstop, below of=app_layer, yshift=-0.3cm] {Start};
    \node (update_position) [process, below of=app_start] {Update position};
    \node (check_queues) [decision, below of=update_position, yshift=-1.3cm] {Queues full?};
    \node (load) [process, below of=check_queues, align=center, yshift=-1.5cm] {Load command \\ queue ? program};
    \node (process_command) [process, below of=load,yshift=-0.25cm] {Process command};
    \node (store_command) [process, align=center, below of=process_command] {Add command \\ to stepper queue};

    % Arrows in Application Layer
    \draw [arrow] (app_start) -- (update_position);
    \draw [arrow] (update_position) -- (check_queues);
    \draw [arrow] (check_queues.east) -- ++(1, 0) |- (update_position.east) node[midway, left, xshift=0.2cm, yshift=+0.25cm,xshift=0.2cm] {Yes};
    \draw [arrow] (check_queues.south) -- ++(0, -0.5) -| (load.north) node[midway, right, yshift=+0.1cm] {No};
    \draw [arrow] (load.south) -- ++(0, -0.5) -- (process_command.north);
    \draw [arrow] (process_command) -- (store_command);
    \draw [arrow] (store_command.west) -- ++(-0.5, 0) |- (update_position.west);


    \node (hal_start) [startstop, below of=hal_layer, yshift=-0.3cm] {Start};
    \node (wait_queue) [process, below of=hal_start] {Wait on queue};
    \node (execute_command) [process, below of=wait_queue] {Execute command};
    \node (wait_command) [process, below of=execute_command] {Wait on command};
    \node (update_info) [process, align=center, below of=wait_command] {Update last \\command};

    % Arrows in HAL Layer
    \draw [arrow] (hal_start) -- (wait_queue);
    \draw [arrow] (wait_queue) -- (execute_command);
    \draw [arrow] (execute_command) -- (wait_command);
    \draw [arrow] (wait_command) -- (update_info);
    \draw [arrow] (update_info.west) -- ++(-0.5, 0) |- (wait_queue.west);

  \end{tikzpicture}

  \caption[Programm diagram]{Programm diagram}
  \label{fig:code_diag}
\end{figure}

\section{Communication layer}

Communication layer handles incoming data on serial line, reading from which is realized efficiently with the aid of RTOS queues.
Upon receiving data the text string is parsed and either push to queue (if we are declaring a programm) or added to programm declaration.

\section{Application layer}

Application layers does two main things - keeps track of current device position and schedules commands to be sent to steppers.
Tracking of current position and end position of last scheduled command also enables the application layer to do calculations needed for absolute positioning and limits enforcement.

One large change from normal G-code interpreters is the fact that if move command is issued only for a single axis second one is free to read next one and start executing it.
If this behavior is undesirable user needs to issue command to both axis - in relative positioning mode zero will result in no motion, in absolute positioning mode current position must be used.



\section{HAL Layer}

Final layer handles basic driving of steppers and provides Application layer with all necessary for position calculation.
In its loop we simply wait for a next command in the stepper queue.
If a command command is received programs set ups its execution and wait for the stepper or both steppers to finish moving after which its moves onto next command.
As all calculations regarding limits, positioning have been done beforehand in the application layer HAL layer can be really performant and efficient.

Main problem arises with generation of accurate PWM signal and having the ability to stop the generation upon given number of steps were taken.
From equation
%
\begin{equation}
  t_{\mathrm{delay}}(s) = \frac{60}{2\cdot N_{\mathrm{steps}} \cdot s},
  \label{eq:delay}
\end{equation}
%
where  $s$ is speed in RMP, $N_{\mathrm{steps}}$ number of steps of the stepper and  $t_{\mathrm{delay}}$ time between steps the time we can calculate that even for RPM of 30 delay between changes on output is 5ms on single stepper.
Take small microstepping of 2:1 into account and the thread would need to execute change every 2.5ms -- to fast to not arise problems with hardware watchdog.
Thus generating signal with purpose designed microcontroller peripherals is necessary.


ESP32 platform offers two solutions for this task - using Remote Controlled Transceiver (RMT) or Motor Control Pulse Width Modulation (MCPWM) combined with PCNT.
While RMT offers special capabilities like smoothly increasing PWM frequency it also brings many disadvantages: generating N number of pulses is available only only on the lastest version of ESP32 microcontrollers \cite{gitRMT}, synchronization can be only done cleanly with rather restrictive RMT specific API, there isn't a easy way to get information how far are we into move \cite{espRMT}.

For these reasons approach of combining MCPWM for pulse generation and PCNT for counting steps was chosen.
This allows for easy synchronization, realization of continous rotation and PCNT provides helpful API for counting steps\cite{espPCNT}.
Only disadvantage is strict limit of 15 bit counter making the maximal number of steps per move 32767.

\subsection{Performance of HAL Layer}


Table \ref{tab:performancepwm} shows stability of the PWM generation of the MCPWM module on different speeds.
Measurements were taken using Saleae Logic Pro 16 logic analyzer without any microstepping enabled.
We can clearly see that deviation in frequency is quite low thought the error increases with frequency and speed is consistently slightly faster than desired.
Still if we were to take 24000 steps with RPM of 120 relative error in time taken would be only $\epsilon = -0.004\%$


\begin{table}[h!]
  \centering
  \caption[Stability of PWM generation]{Stability of PWM generation}
  \begin{tabular}{| m{2cm} || m{2.5cm} | m{2.5cm} | m{2.5cm} | m{2.5cm} |}
    \hline
    RPM & $f_{\mathrm{desired}}$ (Hz) & $f_{\mathrm{low}}$ (Hz) & $f_{\mathrm{high}}$ (Hz) & $f_\mathrm{avg}$ (Hz) \\
    \hline
    10  & 33.334                      & 33.334                  & 33.334                   & 33.334                \\
    30  & 100                         & 100                     & 100.003                  & 100.002               \\
    60  & 200                         & 200                     & 200.01                   & 200.004               \\
    120 & 400                         & 400                     & 400.02                   & 400.007               \\
    \hline
  \end{tabular}
  \label{tab:performancepwm}
\end{table}

Attempt to measure how fast is switching between commands was done however as one can see from pictures
\ref{fig:switching}  the delay between commands isn't perceivable.
At least not on any reasonable RPM.
While the pictures is taken with transmission from step commands at 120 RPM to step command at 60 RPM measurements were also taken for different combinations of commands with similar results.

\begin{figure}[h!]
	\centering
	\includegraphics[width=0.7\textwidth]{../img/120rpm_to60_1.jpg}
	\includegraphics[width=0.7\textwidth]{../img/120rpm_to60_2.jpg}
	\caption[Moment of change between commands with 120RPM and 60RPM]{Moment of change between commands (120RPM $\Rightarrow$  60RPM)}
	\label{fig:switching}
\end{figure}

% RPM & desired  & low interval & high interval & deviation

% speed how fast follow on command gets executed

%% Table how fast are command processed
%% Table with how reliable is timing (with different rpm)

\include{conclusion}

\include{bibliography}
% \printbibliography

\listoffigures

\listoftables

\clearpage
\openright
\end{document}
