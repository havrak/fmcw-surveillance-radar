
\def\PageLayout{single-no-print}
\def\DocLanguage{en}
\def\PackagesIncludeTikz{yes}
\def\PackagesIncludeBib{yes}

\input{dimensions_paper}
\input{packages}
\input{metadata}
\input{macros}
\input{xmp}
\input{doc_paper}
\usepackage{lipsum}  % For generating dummy text (optional)

\newcommand{\sidar}{SiRad Easy\textsuperscript{\copyright} r4}

\begin{document}

\include{doc_paper_title_page_en}

\tableofcontents

\newpage
\pagenumbering{arabic}
\setcounter{page}{1}

\include{introduction}
\pagestyle{fancy}


\chapter{Design parameters}

First of all it is necessary to outline basic requirements we have for the platform. We need to Accommodate \sidar from Radar company and provide control over its tilt and rotation in horizontal plane. Transmission of the data from the radar ought not to be impeded and platform itself must provide sufficient data about its movement. As the radar data processing will be handled in MATLAB the platform needs to provide interface that is accessible from MATLAB, serial line comes up as the most straightforward option.

\section{Physical capabilities}

%% Some equation calculating necessary RPM from radar polling rate

Main design limitations on physical patter stem from radiation pattern of radar used as we want to prevent reflection from the structure.

% cite manual of the radar board for radiation pattern, maybe look up some existing solutions

\section{Software requirements}

NOTE: only basic functionality we want -- programming, spindle, limits and such, point out solution needs to be rather generic

TODO -> move to realization
Main problem on software side is to provide smooth excitation of steppers motors so that the motion is continuos and with predictable speed.
Given simple equation
%
\begin{equation}
	t_{\mathrm{delay}}(s) = \frac{60}{N_{\mathrm{steps}} \cdot s},
	\label{eq:delay}
\end{equation}
%
where  $s$ is speed in RMP, $N_{\mathrm{steps}}$ number of steps of the stepper and  $t_{\mathrm{delay}}$ time between steps the time we can calculate that even for relatively low speed of 60 RPM delay between steps is only $5\mathrm{ms}$, take into account we need to switch state two times we get $2500\upmu\mathrm{s}$ between changes. This makes software generation of control signal hard to do.


In order to provide reliable and timely control over platform's movement executing commands in real time as they come wouldn't suffice.
Thus it is needed to queue general commands and for more complex movement have a way to preprogramm them into the platform and let it do the execution itself.



\chapter{Hardware construction}


%% Picture of the construction both real and cad

\chapter{Software realization}

In order to achieve maximal efficiency in processing commands and  most importantly maintain accurate driving of stepper motors workflow of the program is split into three diactinic layers, as showed on diagram \ref{fig:code_diag}.
With increasing layer the amount of abstraction in command decreases and processing gets easier.
There are two main benefits of this approach:
\begin{itemize}
	\item HAL layer function can be made really simple and thus fast.
	\item Synchronization with queues enables the precompute many commands ahead -- thus executing next move is as fast as possible.
\end{itemize}

TODO: point out while two layer architecture wasn't possible here - wouldn't support programming interface, would require super long buffer for serial communication

\begin{figure}[h!]
	\centering


\begin{tikzpicture}[scale=0.9, node distance=1.5cm]

% Layer headers
\node (comm_layer) [layerheader] at (0, 0) {Communication Layer};
\node (app_layer) [layerheader] at (6, 0) {Application Layer};
\node (hal_layer) [layerheader] at (12, 0) {HAL Layer};

% Communication Layer
\node (comm_start) [startstop, below of=comm_layer, yshift=-0.3cm] {Start};
\node (wait_serial) [process, below of=comm_start] {Wait for serial data};
\node (parse_gcode) [process, below of=wait_serial] {Parse G-code};
\node (parse_success) [decision, below of=parse_gcode, align=center, yshift=-1.3cm] {Parsing\\ Successful?};
\node (store_command) [process, below of=parse_success, align=center, yshift=-1.8cm] {Store command\\ queue ? program};
\node (send_response) [process, below of=store_command,yshift=-0.25cm] {Send response};

% Arrows in Communication Layer
\draw [arrow] (comm_start) -- (wait_serial);
\draw [arrow] (wait_serial) -- (parse_gcode);
\draw [arrow] (parse_gcode) -- (parse_success);
\draw [arrow] (parse_success.east) -- ++(1, 0) |- (send_response.east) node[midway, left, yshift=+0.25cm] {No};
\draw [arrow] (parse_success.south) -- ++(0, -0.5) -| (store_command.north) node[midway, right, yshift=+0.05cm] {Yes};
\draw [arrow] (store_command) -- (send_response);
\draw [arrow] (send_response.west) -- ++(-0.5, 0) |- (wait_serial.west);

% Application Layer
\node (app_start) [startstop, below of=app_layer, yshift=-0.3cm] {Start};
\node (update_position) [process, below of=app_start] {Update position};
\node (check_queues) [decision, below of=update_position, yshift=-1.3cm] {Queues full?};
\node (load) [process, below of=check_queues, align=center, yshift=-1.5cm] {Load command \\ queue ? program};
\node (process_command) [process, below of=load,yshift=-0.25cm] {Process command};
\node (store_command) [process, align=center, below of=process_command] {Add command \\ to stepper queue};

% Arrows in Application Layer
\draw [arrow] (app_start) -- (update_position);
\draw [arrow] (update_position) -- (check_queues);
\draw [arrow] (check_queues.east) -- ++(1, 0) |- (update_position.east) node[midway, left, xshift=0.2cm, yshift=+0.25cm,xshift=0.2cm] {Yes};
\draw [arrow] (check_queues.south) -- ++(0, -0.5) -| (load.north) node[midway, right, yshift=+0.1cm] {No};
\draw [arrow] (load.south) -- ++(0, -0.5) -- (process_command.north);
\draw [arrow] (process_command) -- (store_command);
\draw [arrow] (store_command.west) -- ++(-0.5, 0) |- (update_position.west);


\node (hal_start) [startstop, below of=hal_layer, yshift=-0.3cm] {Start};
\node (wait_queue) [process, below of=hal_start] {Wait on queue};
\node (execute_command) [process, below of=wait_queue] {Execute command};
\node (wait_command) [process, below of=execute_command] {Wait on command};
\node (update_info) [process, align=center, below of=wait_command] {Update last \\command};

% Arrows in HAL Layer
\draw [arrow] (hal_start) -- (wait_queue);
\draw [arrow] (wait_queue) -- (execute_command);
\draw [arrow] (execute_command) -- (wait_command);
\draw [arrow] (wait_command) -- (update_info);
\draw [arrow] (update_info.west) -- ++(-0.5, 0) |- (wait_queue.west);

\end{tikzpicture}

	\caption[Programm diagram]{Programm diagram}
	\label{fig:code_diag}
\end{figure}

\section{Communication layer}

Communication layer handles incoming data on serial line, reading from which is realized efficiently with the aid of RTOS queues.
Upon receiving data the text string is parsed and either push to queue (if we are declaring a programm) or added to programm declaration.
Immediately after data are processed response is send to a user as Communication Layer doesn't check whole pipeline of commands receiving SUCCESS response doesn't mean command will be valid in context it was sent.

\section{Application layer}

Application layers does two main things - keeps track of current device position and schedules commands to be sent to steppers.
As part of scheduling layer calculates end positions of future commands this enables it to enforce user define limits on movement.

\section{HAL Layer}

Final layer handles basic driving of steppers and provides Application layer with all necessary for position calculation.
In its loop we simply wait on next command in queue than setup its execution after which we wait for stepper or both steppers to finish moving.

Main problem arises with generation of accurate PWM signal and having ability to stop generation upon given number of steps wer taken.

%% Table how fast are command processed
%% Table with how reliable is timing (with different rpm)

\include{conclusion}

\include{bibliography}

\listoffigures

\listoftables

\clearpage
\openright
\end{document}
