\def\PageLayout{single-no-print}
\def\DocLanguage{en}
\def\PackagesIncludeTikz{yes}
\def\PackagesIncludeBib{yes}

\input{dimensions_paper}
\input{packages}
\input{metadata}
\input{macros}
\input{xmp}
\input{doc_paper}

\addbibresource{bibliography.bib}

\newcommand{\sidar}{SiRad Easy\textsuperscript{\copyright} }
\newcommand{\boldred}[1]{\textbf{\textcolor{red}{#1}}}
\newcommand{\boldblue}[1]{\textbf{\textcolor{blue}{#1}}}
% \newcommand{\red}[1]{\textcolor{red}{#1}}


\begin{document}

\include{doc_paper_title_page_en}

\tableofcontents

\newpage
\pagenumbering{arabic}
\setcounter{page}{1}

\include{abbreviations}

\include{introduction}

\pagestyle{fancy}

\chapter{FMCW Radar Fundamentals}

Unlike classical Continuous Wave (CW) radars, Frequency Modulated Continuous Wave (FMCW) radars do not broadcast a signal at a single frequency.
Instead, they employ a linear frequency sweep across a defined range.
This approach enables range estimation without requiring pulsed transmissions while still allowing speed measurements using the Doppler shift.
However, velocity calculations in FMCW radars are more complex compared to single-frequency CW radars.

The "MW" suffix in FMCW radar denotes that the system operates in the microwave frequency range.
These high frequencies allow for compact antenna arrays, even enabling on-chip integration.
Additionally, the millimeter-wave (MMW) portion of the spectrum is typically license-free \cite{spektrumCTU} and offers large bandwidths, reducing the risk of interference.

\section{Comparison FMCW Radar to Pulse Radar}

Distance measurement using radar predates FMCW technology by several decades.
Early radar systems primarily relied on pulsed electromagnetic signals, measuring the time taken for the signal to reflect back.
In such systems, speed can be determined using the Doppler effect as
\begin{equation}
	v = \frac{f_\mathrm{dop} c_o}{2f_\mathrm{rad}},
	\label{eq:dopler}
\end{equation}
where $f_\mathrm{dop}$ is doppler frequency, $c_o$ is speed of light and $f_\mathrm{rad}$ is frequency of the radar signal.
Distance is derived from the time of flight $t$ of the signal as
\begin{equation}
	d = \frac{c_o \cdot t}{2}.
	\label{eq:distance}
\end{equation}

While this approach is conceptually straightforward, it has several limitations, particularly in applications requiring high precision at close range.
Achieving fine resolution in distance measurement necessitates very short pulses.
However, to maintain sufficient signal-to-noise ratio (SNR), the transmitted pulse power must remain high, regardless of the number of pulses \cite{jankiraman2018}.

Maintaining high average transmission power poses legal and technical challenges.
It increases the risk of interference with other devices and demands bulky, high-power circuitry -- often requiring high voltages and even vacuum tubes.
Consequently, pulsed radar is predominantly used in applications where fine range resolution is not essential, such as long-range target detection.

One key advantage of pulsed radar is its relatively simple data processing.
In contrast, FMCW radar data processing is more complex due to the interdependence of distance and velocity measurements -- both the frequency sweep and the Doppler shift contribute to frequency changes in the received signal.

\section{Basic principles of ideal FMCW radar}

Let us picture an ideal FMCW radar system sending a periodic chirp with frequency frequency sweep from $f_\mathrm{c}$ to $f_\mathrm{c}+BW$, so called sawtooth waveform.
Other FMCW systems may use a different modulations such a linear triangular modulation or segmented linear frequency Modulation.
These offer some advantages but the nature of the beat signal (which forms a sine wave with sawtooth modulation) is more complex.
Especially in case of triangle when multiple targets are present \cite{jankiraman2018}.
\sidar kit technically uses a segmented linear frequency modulation due to its limited computational power \cite{sidarPRO} but for the sake of simplicity we will stick to the ideal sawtooth waveform.

\begin{figure}[h!]
	\centering
\begin{tikzpicture}[>=latex, scale=1]

% Axes
\draw[->] (0, 0) -- (8, 0) node[below] {$t$};
\draw[->] (0, 0) -- (0, 5) node[left] {$f$};

% Horizontal lines for BW
\draw[dashed] (0, 4.5) -- (7.5, 4.5);
\draw[dashed] (0, 1) -- (7.5, 1);
\draw[dashed] (2.5, -0.05) -- (2.5, 4.7);

% Labels for fc and BW
\node[left] at (0, 1) {$f_c$};
\draw[<->] (-0.5, 1) -- (-0.5, 4.5) node[midway,left] {$BW$};

% Triangular wave for Tx
\draw[thick,blue] (0, 1) -- (2.5, 4.5);
\draw[thick,blue]	(2.5, 1) -- (5, 4.5);
\draw[thick, dashed, blue] (5, 1) -- (6, 2.4);

% Triangular wave for Rx (offset version)
\draw[thick,red] (0.5, 1) -- (3, 4.5);
\draw[thick,red] (3, 1) -- (5.5, 4.5);
\draw[thick, dashed, red] (5.4, 1) -- (6.4, 2.4);

% Label for Tch
	\draw[-] (2.5, -0.05) -- (2.5, 0.05) node[below] {$T_{\text{ch}}$};

% Labels for Tx and Rx
\node[blue] at (4.2, 4.1) {\small Tx};
\node[red] at (5.3, 3.7) {\small Rx};

% Sweep slope and fb
\draw[<->] (1, 1) arc[start angle=0, end angle=55, radius=1];
\node at (1.5, 1.3) {\small $k_{\text{sw}}$};
\draw[<->] (1.5, 2.37) -- (1.5, 3.12) node[above, left] {$f_b$};

% Small time delay (tau)
\draw[<->] (2.5, 0.7) -- (3, 0.7) node[midway,below] {$\tau$};

\end{tikzpicture}

	\caption[Ideal relation of frequency and time for received and sent signal]{Ideal relation of frequency and time for received and sent signal}
	\label{fig:fmcw_ideal}
\end{figure}

We can clearly see that in given time $t$ the frequency spread from sent signal to received signal is proportional to the time delay $\tau$.
However doing some simple subtraction in spectrogram of the both signals isn't really feasible -- the calculation need to take a smarter approach.


Let us define the chirp slope $k_\mathrm{sw}$ we can describe the change in frequency of the received signal as
\begin{equation}
	\Delta f_\mathrm{s}(t) = k_\mathrm{sw}t = \frac{BW}{T_\mathrm{ch}} t,
	\label{eq:deltaf}
\end{equation}
where $t$ is the time goes from 0 to chirp length $T_\mathrm{ch}$.
Standard equation of FM signal can be written as
\begin{equation}
	s_\mathrm{t}(t) = A \cos\left(\omega_c t + 2\pi \int_{0}^{t} f_\mathrm{s}(t) \mathrm{d}t\right),
	\label{eq:fm}
\end{equation}
where $A$ is amplitude of the signal, $\omega_c$ is carrier frequency and $f(s)$ is frequency of the signal.
Substituting (\ref{eq:deltaf}) into (\ref{eq:fm}) we get the signal borrowed from the radar
\begin{equation}
	s_\mathrm{t}(t) = A \cos(\omega_c t + \pi k_\mathrm{sw}t^2).
	\label{eq:fm2}
\end{equation}

Signal bounced back from the target will have the same equation with the only difference being the time delay $\tau$,
\begin{equation}
	s_\mathrm{r}(t) = A \cos(\omega_c (t - \tau) + \pi k_\mathrm{sw}(t - \tau)^2).
	\label{eq:fm3}
\end{equation}
Now we can calculate the product of the two signals, this can be done easily in the real world using a frequency mixer.
The result of the multiplication is
\begin{align}
	s(t) = s_\mathrm{r}(t) \cdot  s_\mathrm{t}(t) &= \frac{A^2}{2}\cos\left(2(\omega_c - 2\pi k_\mathrm{sw}T_\tau)t + 2\pi k_{sw}t^2 + (\pi k_\mathrm{sw} \tau^2 - \omega_c \tau) \right)+ \nonumber \\
	&+\frac{A^2}{2} \cos\left(2\pi k_\mathrm{sw} \tau t + (\omega_c \tau - \pi k_\mathrm{sw} \tau^2)\right).
	\label{eq:fm4}
\end{align}
First additive term will lead to a signal with very high frequency, well above $2\omega_c$, this term doesn't carry any useful information and is usually filtered out -- either by low pass filter or the frequency mixer itself \cite{graham2005}.
Second term is so call beat signal whose frequency is directly proportional to the time delay $\tau$.
Applying a first time derivative to the cosine argument we get the frequency of the beat signal.
\begin{equation}
	f_\mathrm{b} = \frac{1}{2\pi}\frac{\partial}{\partial t} \left(2\pi k_\mathrm{sw} \tau t + (\omega_c \tau - \pi k_\mathrm{sw} \tau^2)\right) = k_\mathrm{sw} \tau.
	\label{eq:fb}
\end{equation}

Calculating the distance to the target is now trivial, delay $\tau$ is equal to the time it takes for the signal to travel to the target and back
\begin{equation}
	R = \frac{c_0 \tau}{2},
	\label{eq:distance2}
\end{equation}
By substituting (\ref{eq:fb}) into (\ref{eq:distance2}) we get the equation for distance
\begin{equation}
	R = \frac{c_0 f_\mathrm{b}}{2k_\mathrm{sw}}= \frac{c_o f_\mathrm{b} T_{\mathrm{ch}}}{2 BW}.
	\label{eq:distance3}
\end{equation}


\subsection{Limits of Range Measurement}

Absolute limit for maximal distance is given by the time it takes for the signal to travel from the radar to the target and back.
Would the distance be greater than a time of single chirp the signal would be interpreted as coming from a closer target.
That gives us an maximal limit on beat frequency $f_\mathrm{b} = BW$.

However in most case the limit will imposed not by $T_\mathrm{ch}$ respectively $BW$ but by sampling frequency $f_\mathrm{s}$.
In order to avoid aliasing the Nyquist-Shannon theorem must be satisfied thus limiting the maximal beat frequency to $f_\mathrm{s}/2$ and resulting in maximal distance of
\begin{equation}
	R = \frac{c_o f_\mathrm{s}}{4k_\mathrm{sw}}.
	\label{eq:distance4max}
\end{equation}

While sampling with frequency $f_\mathrm{s}$ we get $N =\mathrm{f}_\mathrm{s} T_\mathrm{ch}$ samples applying a DFT to the signal we get $N$ samples in spectrum with frequency resolution of
\begin{equation}
	\Delta f_\mathrm{b} = \frac{f_\mathrm{s}}{N} = \frac{1}{T_{ch}}.
	\label{eq:resolution}
\end{equation}
We can see that the resolution of spectrum is only inversely proportional to the chirp length and doesn't have any relation to sampling frequency \cite{jankiraman2018}.
Now we can enter $\Delta f_\mathrm{b}$ into (\ref{eq:distance3}) to get the minimal distance that can be measured as
\begin{equation}
	\Delta R = \frac{c_o}{2BW}
	\label{eq:distance5min}
\end{equation}
Thus in order to increase resolution in range a wider bandwidth is needed.

There are of course other effect impeding the resolution of the radar system -- such a phase noise around targets or sweep nonlinearity.
Sweep Linearity can be both in the ramp itself -- leading to decreasing resolution with range (with both linear and quadratic errors present) \cite{graham2005} (Appendix D and E).
Or in sweep recovery (time to return to the start of the sweep) which leads to a fix decrease in resolution \cite{piper1995}.
Both are however largely compensated in modern radar systems by using a closed feedback loop \cite{graham2005}.


\subsection{Speed Measurement}

In order to demonstrate the effect of moving target on the beat frequency we can redefine the time delay $\tau$ as
\begin{equation}
	\tau = \frac{2(R_0+vt)}{c_o}
	\label{eq:tau}
\end{equation}
where $R_0$ is the initial distance to the target and $v$ is the radial speed of the target.
Within a single chirp there is no way to distinguish between the effects distance and speed of the target -- thus multiple chirps are needed.
Rewriting \label{eq:tau} as
\begin{equation}
	\tau = \frac{2(R_0 v(nT_\mathrm{ch} + t_\mathrm{s}))}{c_0}
	\label{eq:tau2}
\end{equation}
where $n$ is the number of chirps, $T_\mathrm{ch}$ is the chirp length and $t_\mathrm{s}$ denotes time withing  a single chirp ($0 \leq t_\mathrm{s} \leq T_\mathrm{ch}$).
Substituting (\ref{eq:tau2}) into low frequency part (\ref{eq:fm4}) leads to very complex equation, however according to \cite{suleymanov2016} most of the terms can be neglected leading us to
\begin{equation}
	s(t_\mathrm{s}, n) = \frac{A^2}{2} \cos\left(\frac{4\pi k_\mathrm{sw} R_0}{c_0} t_\mathrm{s} + \frac{2\omega_c v n}{c_0} T_\mathrm{ch} + \varphi_0 \right),
	\label{eq:fb2}
\end{equation}
where $\varphi_0$ is a phase shift given by the initial distance to the target.
Its clear that first element describes predominantly the distance to the target and the second one the speed of the target.
We can also see that speed will not affect a beat frequency in a single spectrum but will lead to a phase shift across multiple spectrums.

In order to calculate doppler shift frequency
\begin{equation}
	f_\mathrm{d} = \frac{2f_\mathrm{c}v}{c_0},
	\label{eq:doppler2}
\end{equation}
we can use 2D Fourier transform -- first in time within a single chirp and then in time across multiple chirps.
This will lead to a so called range-Doppler map which on one axis contains information about speed and on second distance of the target \cite{suleymanov2016}.

Speed resolution is derived from a number of chirps $N$ we are analyzing and their length $T_{\mathrm{ch}}$ as
\begin{equation}
	\Delta v = \frac{c_0}{2f_c} \frac{1}{NT_{\mathrm{ch}}}.
	\label{eq:doppler3}
\end{equation}
On the other hand the increase in number of chirps will affect the distance measurement if the target movement speed is sufficiently high.



\chapter{\sidar}

Indie Semiconductor's \sidar is an FMCW radar system development kit designed primarily for automotive applications.
Out of the box, it offers two headers a 24~GHz and a 122~GHz module both based on ICs from Indie Semiconductor (TRX-024-007 and TRA-120-001, respectively).
Both are strictly SISO IC with two antennas -- one for receiving another for transmitting so azimuth estimation is not possible by default.

\begin{figure}[h!]
	\centering
	\includegraphics[width=0.7\textwidth]{../img/sidar.png}

	\caption[\sidar \cite{sidarMANOld}]{\sidar  24~GHz configuration}
	\label{fig:sidar}
\end{figure}

Direct communication with the radar board itself is not possible, or at least, the communication interface is undocumented.
Instand there is always and intermediary in the form of  STM32 Nucleo series microcontroller.
To this microcontroller does the user connect either directly with UART over USB or with WiFi over on board ESP32.
Both are relatively low bandwidth communication -- the serial maxing at baudrate of 1~000~0000.

\begin{figure}[h!]
	\centering
	\includegraphics[width=0.7\textwidth]{../img/sidar_flow.png}
	\caption[Flow of Radar Measurement on \sidar \cite{sidarPRO}]{Flow of Radar Measurement on \sidar}
	\label{fig:sidarFlow}
\end{figure}

The devkit is designed for easy integration into existing projects; however, this unfortunately poses limitations for this thesis.
In normal operation, the radar system functions as a black box (processing schema shown in \ref{fig:sidarFlow}), implementing its own filtering, FFT, and CFAR algorithms while only reporting a target list to the user.

This entire sequence can be triggered either internally (driven by a configurable oscillator) or externally (via a GPIO pin or UART input).
Once trigger is received the device carries out a user configured number of chirps.
The chirp length is determined by the number of sampling steps and the ADC sampling time as follows:
\begin{equation}
	t_\mathrm{ramp} = \frac{t_\mathrm{ADC} \cdot  (N_\mathrm{samples} + 85)}{36\,\, \mathrm{MHz}} \,\, \mu\mathrm{s},
	\label{eq:sampling}
\end{equation}
with the manufacturer recommending an optimal time of 1~ms for good SNR \cite{sidarPRO}.
What happens to the sampled ramps remains unclear, as the manufacturer has not provided details.
It is likely that the data are somehow averaged to improve the SNR of the reported signal.
As only $N_\mathrm{samples}$ are reported by the radar but according to manufacturer provided equation (\ref{eq:sampling}) each ramp should be sampled with that number of samples.
Additionally, due to the devkit's limited computational resources, the radar does not emit a continuous sawtooth waveform but rather a segmented one \cite{sidarPRO}.

Unfortunately whole devkit is clearly designed primarily for range detection with little to no regard payed for speed measurement.
Aside from need to turn of averaging of the ramps radar doesn't maintain constant intervals between chirps.
This is the case even when relying on manual triggering of the radar, relying on self trigger yields even worse results.
Not to mention radar doesn't provide any information about timing.

When measuring reporting interval with 20~ms trigger radar achieved average time of 20.5~ms with standard deviation of 1.3~ms.
However from time to time they were outlier when report came in only after 30~ms in worst case or 16~ms in best case measured on 5000 samples.
In order to rule out that the problem isn't only in reporting output signal from the radar was captured by Rohde \& Schwarz FSW26 Signal and Spectrum Analyzer.
By analyzing some 40 samples, measured with same triggering interval of 20~ms, the average time between chirps was 20.7~ms with standard deviation of 0.7876~ms.

Unfortunately radar truly doesn't maintain constant intervals between chirps which severely limits accuracy of speed measurement.
In addition trying to establish relation between when a chirp was broadcasted and when data were received would be quite challenging.
Thus all processing estimates that chirp was broadcasted shortly after last data were received.


\section{Outline of Chosen Configuration }


For the purpose of this project, the devkit was configured to output raw data from the 12-bit ADC in the form of in-phase and quadrature components of the signal.
This allows for a more detailed analysis of the radar system and enables the implementation of custom signal processing algorithms.
For these reasons, the default windowing and undocumented filtering was also disabled.
As for trigger as previously stated self trigger isn't that consistent and thus manual trigger sent over UART was used.

After configuration of the output regimes, it is necessary to find the correct balance between the number of ramps, samples, and sampling frequency.
Since the radar will be in motion, frequent updates are crucial to ensure accurate reporting.
Faster updates allow for higher platform speeds or make it possible to use neighboring samples to aid in evaluation of current one (As the angular distance between them remains relatively small.).

Even with irregular chirp intervals rough speed estimation can still be done.
As deviation isn't that large the error of using standard FFT should still be within acceptable limits.
If not there is the possibility of easily swapping to non uniform DFT and basing chirp intervals in reporting intervals.
For any speed estimation to be possible however the number of ramps withing a group must be fixed at one.
As any averaging would destroy information about doppler shift.

Another parameter to consider in relation to rotary application is AGC.
Using it adds two additional ramps that are used solely to set gain value but it also can lead to inconsistent weights of values between two neighboring data sets.
Former only introduces a small slowdown but the letter could be a problematic, especially since radar doesn't really report change in AGC value.
Thus its safest to turn AGC off and set the gain manually depending on how the readings appear in post processing.

It is also important to note that the radar system is not well-suited for on-the-fly configuration changes.
Applying a new configuration takes a considerable amount of time, and the radar does not provide any feedback to indicate when a new configuration can be safely applied.
As a result, commonly used techniques such as alternating chirp slope or frequency modulation are not feasible.

Regarding the output format, the radar system supports two options: binary and TSV.
Since the output speed does not differ significantly between the two, the primary deciding factor is the ease and speed of parsing.
Even though MATLAB is not particularly optimized for parsing binary data, it still processes binary output approximately 40\% faster than human-readable TSV data.

\section{24~GHz Header}

Center of 24~GHz header is a SISO TRX-024-007 transceiver which integrates low noise amplifier, frequency mixer, filters and VCO into a single chip.
It is primarily designed to operate in the ISM band (24.0--24.25GHz), with an additional ultra-wideband mode supporting 23--26~GHz \cite{sidarTRX24}.
On the \sidar there is no distinction made between  those two modes and the user is free to set any bandwidth \cite{sidarPRO} .
The transmitter output power ranges from 2.5~dBm to 6~dBm, depending on the configuration \cite{sidarTRX24}.
A maximum range of 400~m is advertised \cite{sidarMANOld}, though this is likely under ideal conditions when observing a large target.
Also as previously stated the radar will operate on much lower sampling frequency than needed to achieve such results.


As shown in Figure \ref{fig:sidar}, the chip is connected to two microstrip patch antennas.
The patches are arranged in a relatively standard configuration, forming a 6×4 array with spacing approximately equal to half the wavelength at 24~GHz.

Since the manufacturer did not provide any information about the radiation pattern of the array, a simulation was conducted using the CST simulation suite.
Additionally, the manufacturer did not disclose the substrate parameters for the radar board specifically.
Fortunately, the TRX-024-007 datasheet includes a board stack-up for the chip's evaluation board.
It was assumed that the same stack-up would be used—18~$\mu$m copper for the traces and ground plane, with a 250~$\mu$m thick Rogers RO4350B substrate \cite{sidarTRX24}.

\begin{figure}[ht!]
	\centering
	\includegraphics[width=0.6\textwidth]{../img/boundaries.png}
	\caption[Simulated 24 GHz header with boundary conditions showed]{Simulated 24 GHz header with boundary conditions showed}
	\label{fig:boundaries}
\end{figure}

After measuring the dimensions of the array using an optical microscope, the entire array was redrawn in CST Studio.
Figure \ref{fig:boundaries} shows the applied boundary conditions: the antenna was placed in open space, and an $H=0$ condition was set along the symmetry plane to speed up the simulation.

After performing a standard time-domain simulation with an excitation signal ranging from 0 to 26GHz, the antenna array exhibited a minimum reflection coefficient $s_{11} \doteq -26.4 \mathrm{~dB}$ at 23A.478~GHz with second minimum at 24.518~GHz (Figure \ref{fig:s11}).
Lack of minimum at 24~GHz may be attributed to measurement difficulties (The etching quality of the copper traces was suboptimal.) and the neglecting variations of substrate parameter due to interactions of different layers.

At both frequencies with minimal reflection, a far-field radiation pattern was calculated.
For clarity, only the 24.518~GHz pattern is shown in Figure \ref{fig:farfield3d}.
The main lobe width was measured at approximately 16 degrees (Figure \ref{fig:farfield180}) along the 180-degree norm (for orientation refer to the red cone on the PCB), with a peak gain of 18.6~dBi and side-lobe suppression of -13~dB.
For the 90-degree norm, the main lobe width (Figure \ref{fig:farfield90}) was 30 degrees, with side-lobe suppression of -10~dB.

\begin{figure}[h!]
	\centering
	\includegraphics[width=0.9\textwidth]{../img/s11.png}
	\caption[$s_{11}$ parameter of the 24~GHz header]{$s_{11}$ parameter of the 24~GHz header}
	\label{fig:s11}
\end{figure}


\begin{figure}[h!]
	\centering
	\includegraphics[width=0.43\textwidth]{../img/farfield3d.png}
	\caption[Radiation pattern of 24~GHz header -- 3D view]{Radiation pattern of 24~GHz header -- 3D view}
	\label{fig:farfield3d}
\end{figure}

\begin{figure}[h!]
	\centering
	\includegraphics[width=0.9\textwidth]{../img/farfield180.png}
	\caption[Radiation pattern of 24~GHz header -- 180° norm]{Radiation pattern of 24~GHz header -- 180° norm}
	\label{fig:farfield180}
\end{figure}

\begin{figure}[h!]
	\centering
	\includegraphics[width=0.9\textwidth]{../img/farfield90.png}
	\caption[Radiation pattern of 24~GHz header -- 90° norm]{Radiation pattern of 24~GHz header -- 90° norm}
	\label{fig:farfield90}
\end{figure}


\section{122~GHz Header}

\begin{figure}[h!]
	\centering
	\includegraphics[width=0.7\textwidth]{../img/sidar122.png}
	\caption[\sidar with 122~GHz header \cite{sidarPRO}]{\sidar with 122~GHz header}
	\label{fig:sidar122}
\end{figure}

The 122~GHz header is based on the TRX-120-001 transceiver, which, in addition to the essential components required for RF transmission and reception, also incorporates two on-chip antennas.
It's designed to operate in the 122-123~GHz band, with output power ranging from -7~dBm to 1~dBm \cite{sidarTRX122}.
The chip is capable of detecting large targets at distances of up to 40~m \cite{sidarMANOld}.

Out of the box performance of the system is quite bad (Figure \ref{fig:sidar122rad}) with width of the main lobe being roughly $\pm40\text{°}$ in both E-plane and H-plane \cite{sidarTRX122}.
However, this can be significantly improved using the supplied collimator lens, reducing the main lobe width to $\pm4\text{°}$ \cite{sidarTRX122col} (see Figure \ref{fig:sidar122rad}).


\begin{figure}[h!]
	\centering
	\includegraphics[width=0.85\textwidth]{../img/sidar122rad.jpg}
	\caption[Radiation pattern of 122~GHz header comparison \cite{sidarTRX122col}]{Radiation pattern of 122~GHz header comparison}
	\label{fig:sidar122rad}
\end{figure}



\chapter{Rotary Platform}

Following chapter outlines design process and operation of a rotary platform specifically designed for \sidar radar system.

\section{Platform Design Parameters}


To begin, it is essential to outline the fundamental requirements for the platform.
These stem from the physical capabilities of the \sidar and need to provide easy to use interface to control the platform.

\subsection{Physical Capabilities}

The primary constraints on the physical design arise from the radar’s radiation pattern (considering both the 24~GHz and 122~GHz headers).
These patterns determine the necessary clearance in front of the radar and, more importantly, the precision required for platform movement.
As stated previously, the 24GHz radar has a main lobe width of approximately $\pm7\text{°}$, while the 122~GHz radar has a main lobe width of $\pm4\text{°}$ \cite{sidarTRX122}.
To minimize strong reflections from both the main lobe and side lobes, a conservative clearance of $\pm45\text{°}$ in front of the radar was selected.

Due to the relatively low angular resolution of the radar, high platform precision is not required.
A basic 200-step stepper motor with a step size of 1.8\text{°} is sufficient; however, smoother motion simplifies software compensation of the movement.
Given the radar’s low weight—measured at 120~g, including the mounting bracket, smoothness of movement can be achieved solely through motor microstepping.

High-speed movement is unnecessary for this application.
The manufacturer specifies a maximum update frequency of 50 Hz, corresponding to a new measurement every 20ms \cite{sidarMAN}.
In this use case, the update frequency will be closer to 10-20~Hz.
Using
%
\begin{equation}
  t_{\mathrm{angle}} = \frac{60}{360\cdot N_{\mathrm{RMP}}} \cdot  \alpha,
  \label{eq:poll}
\end{equation}
%
where $t_{\mathrm{angle}}$ represents the time spent traveling an angle $\alpha$ in seconds, and $N_{\mathrm{RPM}}$ is the number of rotations per minute, we can calculate that even at a low rotational speed of 60~RPM, an 8-degree movement (matching the angular width of the main lobe for the 122~GHz radar) takes only 10~ms -- too fast to properly interpret the data.


\subsection{Software Requirements}

Given its widespread adoption as an industry standard for controlling multi-axis machines, G-code over serial is a natural choice for the platform's communication format.
Beyond the basic functionality typically offered by G-code interpreters, the platform must support additional features to reduce the user's manual control burden.
These features include the ability to define movement limits and preprogram sequences of movements for autonomous execution by the platform.

For uplink communication, the platform must provide real-time information about its current position and speed.
This data enables the user to make any mathematical corrections and properly interpret radar's gathered data.


\section{Platform Construction}

As the platform needs to transmit data from the rotating section to the stationary base, a slip ring is required.
Due to the relatively low transmission speed of the radar and the absence of special requirements such as waterproofing, an affordable model, UH3899-01-0810 from Senring, was selected.
This is a classical contact slip ring that features a dedicated USB~2.0 connection along with 8 additional signal wires, with an advertised insertion loss of less than 2~dB \cite{slipring}.
More problematic than loss is cross talk between signal wires when stepper motor responsible for tilting the radar is running.
USB~2.0 connection doesn't seem that effected, however endstop used for homing requires adding a low pass filter to its output to help with noise.

Unfortunately, the manufacturer opted for a non-standard male-male USB~2.0 connection, requiring a female-female adapter to connect the radar to the slip ring.
Additionally, when used with a poor-quality cable, the system exhibits signal integrity issues.
These problems could likely be mitigated by integrating a signal conditioner into the transmission line.

The rest of the design is relatively simple.
The fixed section mounts the slip ring with the stepper motor positioned underneath, directly driving a shaft connected to the rotating platform.
The connection is secured using long M4 set screws that pass through the slip ring and hold the shaft in place.
A 3D-printed housing serves only as a centering guide and is not load-bearing.

The rotating section features a simple A-frame design that elevates the radar, which is mounted on bearings, allowing it to tilt freely.
To control the tilt, a second stepper motor is mounted on the rotating platform and linked to the radar via a 2:1 down-gearing ratio using a standard 8~mm belt.
An optical endstop, used for homing of the platform, is mounted on the second support strut.

Since mechanical stresses are minimal, most parts can be 3D-printed using standard PLA filament.
The only non-3D-printed components are the screws, bearings, and stepper motors.
The final assembly (Figure~\ref{fig:side_by_side}) measures approximately 33~cm in height and has a footprint of $20\times20$~cm.

While the platform offers some ability to tension the belt in currently printed configuration the range is not sufficient to fully tighten the belt.
While slippage is not a problem radar there is some slack in radar's tilt.
However as the radars capabilities in this direction aren't particularly high it was decided not to reprint the whole assembly.
Still in supplied 3D models these issues were fixed.

\begin{figure}[h!]
  \centering
  \begin{subfigure}[b]{0.45\textwidth}
    \centering
    \includegraphics[width=\textwidth]{../img/whole_assembly_2.png} % Replace with your image path
    \caption{3D render}
  \end{subfigure}
  \hspace{0.05\textwidth} % Adjust spacing
  \begin{subfigure}[b]{0.45\textwidth}
    \centering
    \includegraphics[width=0.75\textwidth]{../img/assembly_photo.jpg} % Replace with your image path
    \caption{Photo}
  \end{subfigure}
  \caption{Form of the final assembly}
  \label{fig:side_by_side}
\end{figure}


\subsection{Platform Electronics}

The electronic aspect of the platform is relatively simple, involving only two main tasks: driving the stepper motors and implementing a homing mechanism.

Given the low load on the stepper motors and the platform's inability to accumulate significant momentum, a basic stepper driver without feedback control is sufficient.
For this purpose the A4988 stepper driver was chosen due to its low cost, microstepping capabilities and basic current control \cite{a4988}.
A minor drawback is the lack of feedback from the driver to the microcontroller, including the absence of stall detection.
To simplify the design, A4988 development kits were used and soldered onto a prototyping board, eliminating the need for a custom PCB.
In addition if the need arieses A4988 development kit can be replaced by one with a different IC, such as TCM2209, as manufacturers keep the same pinout and dimensions on these complementary kits.
This might be necessary in application where platform loudness would be a serious problem as A4988 produces rather noisy driving signal leading to even 20 dB higher operating volume \cite{a4988_sound}.


For homing implementation, two potential solutions were considered: Hall effect sensors and optical gates.
Hall effect sensors offer the advantage of angle sensing, allowing correction for positional drift during operation; however, they require precise alignment.
If the orthogonal Hall effect sensor is not perfectly placed along the axis of rotation, calibration becomes necessary \cite{hall}.
While feedback would be beneficial, the microcontroller already tracks each step taken by the motor during normal operation, making it possible to determine the platform's position purely in software.
Thus for simplicity and ease of integration, optical gates were selected.

The system is controlled by an ESP32 microcontroller.
The ESP32-C6 version was chosen due to the author's extensive experience with this particular model.
However, since the system does not require specialized peripherals or high processing power, any ESP32 variant would be sufficient.

\section{Platform Software Realization}

To maximize efficiency in processing commands and ensure accurate stepper motor control, the program workflow is divided into three distinct layers, as illustrated by figure \ref{fig:code_diag}.

The commonly used two-component architecture—where one component handles communication/command parsing and the other manages execution—was deemed unsuitable for this use case.
Such an approach would complicate integration of programming interface and require just-in-time processing of commands, which could lead to performance issues.

In the chosen architecture, the degree of abstraction decreases with each successive layer, simplifying processing at each step.
This design allows the final layer to operate with maximum efficiency, where transition from one command to the next is primarily limited by the inertia of stepper motors and not by the software.

\begin{figure}[h!]
  \centering


  \begin{tikzpicture}[scale=0.9, node distance=1.5cm]

    % Layer headers
    \node (comm_layer) [layerheader] at (0, 0) {Communication Layer};
    \node (app_layer) [layerheader] at (6, 0) {Application Layer};
    \node (hal_layer) [layerheader] at (12, 0) {HAL Layer};

    % Communication Layer
    \node (comm_start) [startstop, below of=comm_layer, yshift=-0.3cm] {Start};
    \node (wait_serial) [process, below of=comm_start] {Wait for serial data};
    \node (parse_gcode) [process, below of=wait_serial] {Parse G-code};
    \node (parse_success) [decision, below of=parse_gcode, align=center, yshift=-1.3cm] {Parsing\\ Successful?};
    \node (store_command) [process, below of=parse_success, align=center, yshift=-1.8cm] {Store command\\ queue ? program};
    \node (send_response) [process, below of=store_command,yshift=-0.25cm] {Send response};

    % Arrows in Communication Layer
    \draw [arrow] (comm_start) -- (wait_serial);
    \draw [arrow] (wait_serial) -- (parse_gcode);
    \draw [arrow] (parse_gcode) -- (parse_success);
    \draw [arrow] (parse_success.east) -- ++(1, 0) |- (send_response.east) node[midway, left, yshift=+0.25cm] {No};
    \draw [arrow] (parse_success.south) -- ++(0, -0.5) -| (store_command.north) node[midway, right, yshift=+0.05cm] {Yes};
    \draw [arrow] (store_command) -- (send_response);
    \draw [arrow] (send_response.west) -- ++(-0.5, 0) |- (wait_serial.west);

    % Application Layer
    \node (app_start) [startstop, below of=app_layer, yshift=-0.3cm] {Start};
    \node (update_position) [process, below of=app_start] {Update position};
    \node (check_queues) [decision, below of=update_position, yshift=-1.3cm] {Queues full?};
    \node (load) [process, below of=check_queues, align=center, yshift=-1.5cm] {Load command \\ queue ? program};
    \node (process_command) [process, below of=load,yshift=-0.25cm] {Process command};
    \node (store_command) [process, align=center, below of=process_command] {Add command \\ to stepper queue};

    % Arrows in Application Layer
    \draw [arrow] (app_start) -- (update_position);
    \draw [arrow] (update_position) -- (check_queues);
    \draw [arrow] (check_queues.east) -- ++(1, 0) |- (update_position.east) node[midway, left, xshift=0.2cm, yshift=+0.25cm,xshift=0.2cm] {Yes};
    \draw [arrow] (check_queues.south) -- ++(0, -0.5) -| (load.north) node[midway, right, yshift=+0.1cm] {No};
    \draw [arrow] (load.south) -- ++(0, -0.5) -- (process_command.north);
    \draw [arrow] (process_command) -- (store_command);
    \draw [arrow] (store_command.west) -- ++(-0.5, 0) |- (update_position.west);


    \node (hal_start) [startstop, below of=hal_layer, yshift=-0.3cm] {Start};
    \node (wait_queue) [process, below of=hal_start] {Wait on queue};
    \node (execute_command) [process, below of=wait_queue] {Execute command};
    \node (wait_command) [process, below of=execute_command] {Wait on command};
    \node (update_info) [process, align=center, below of=wait_command] {Update last \\command};

    % Arrows in HAL Layer
    \draw [arrow] (hal_start) -- (wait_queue);
    \draw [arrow] (wait_queue) -- (execute_command);
    \draw [arrow] (execute_command) -- (wait_command);
    \draw [arrow] (wait_command) -- (update_info);
    \draw [arrow] (update_info.west) -- ++(-0.5, 0) |- (wait_queue.west);

  \end{tikzpicture}

  \caption[Program flow diagram]{Program flow diagram}
  \label{fig:code_diag}
\end{figure}

\subsection{Communication layer}

The communication layer manages incoming data over the serial line, with efficient handling facilitated with the aid of RTOS queues.
Upon receiving data the text string is parsed and either pushed to a queue or added to programm declaration, in case we are currently declaring program.

Immediately after parsing, a response is send to the user confirming whether the command was parsed correctly or not.
However, as the communication layer does not a can not check command within context of all previous commands, it is possible that command will be parsed correctly but its execution will fail in the application layer.



\subsection{Application layer}

The application layer performs two primary functions: tracking the current device position and scheduling commands to be sent to stepper motors.
Aside from current position the program also keeps track of the end position of the last scheduled command.
Thanks to this the application layer make necessary calculations to facilitate absolute positioning and enforce movement limits.

A key departure from standard G-code interpreters, like \cite{duet}, is how the platform handles single-axis move commands.
When a move command targets only one axis, the other axis remains free to read next command and begin its execution.
If this behavior is undesirable, the user must issue commands for both axes.
In relative positioning mode, a zero value results in no motion; in absolute positioning mode, the command must specify the current position to prevent movement.

This behavior is a necessary side effect of the spindle regime, which typically cannot be toggled on or off dynamically.
Another consequence is the requirement for separate positioning modes for each axis.
Continuous rotation prevents calculations of a move’s end position, making it impossible to make calculation for absolute positioning commands -- thus necessitating relative positioning.
However it would be rather restrictive to force user to relative positioning on second axis, therefore the independent positioning settings.

In order to support or possible operating regimes a manual override mode was also implementing.
This enables the user to manually push a move command directly to stepper queues totally skipping the application layer.
Primary usecase of this mode is to allow tracking of targets or other application that require real time control of the platform.
However in this regime no limits are enforced and the platform operates strictly in relative positioning mode.


\subsection{HAL Layer}

The final layer manages stepper motor control and provides the application layer with essential data for position calculations.
In its loop, the program waits for the next command in the stepper queue.
Upon receiving a command, it sets up execution, waits for one or both steppers to complete their movement, and then proceeds to the next command.
Since limit and absolute positioning calculations are handled in the application layer whole routine remains highly efficient.

The main challenge lies in generating precise PWM signals (Used to control stepper motors drivers.) and stopping signal generation after a specific number of steps.
Using the equation:
%
\begin{equation}
  t_{\mathrm{delay}}(s) = \frac{60}{2\cdot N_{\mathrm{steps}} \cdot s},
  \label{eq:delay}
\end{equation}
%
where $s$ is speed in RPM, $N_{\mathrm{steps}}$ is the number of steps (Anywhere from 200 to 1600 depending on microstepping.), and $t_{\mathrm{delay}}$ is the time between steps, we calculate that even at 30 RPM, the delay between output changes is 5 ms per step.
With microstepping at a 2:1 ratio, this reduces to 2.5 ms -- faster than lowest sleep interval on ESP32 and without sleeping the RTOS watchdog will trigger.
Therefore, signal generation must leverage specialized microcontroller peripherals.

The ESP32 platform offers two options: Remote Controlled Transceiver (RMT) and Motor Control Pulse Width Modulation (MCPWM) combined with Pulse Counter (PCNT).
While RMT allows smooth PWM frequency adjustments, it has several drawbacks.
Such as the fact that generating a specific number of pulses is supported only on newer ESP32 models \cite{gitRMT}, synchronization is restricted to its proprietary API, and there is no straightforward way to track progress during a move \cite{espRMT}.

For these reasons, MCPWM and PCNT were chosen.
MCPWM handles pulse generation, while PCNT counts steps, enabling easy synchronization, continuous rotation, and a robust API for step tracking \cite{espPCNT}.
The only limitation is the PCNT’s 15-bit counter, which caps the maximum steps per move at 32.767.


\subsubsection{Performance of the HAL Layer}

Table \ref{tab:performancepwm} illustrates the stability of PWM generation by the MCPWM module at various speeds.
Measurements were conducted using a Saleae Logic Pro 16 logic analyzer, with no microstepping enabled.

The results show that frequency deviation is minimal, though the generated speed is consistently marginally faster than the target, and  the error increases slightly with higher speeds.
Nevertheless, when measuring time of 24,000 steps at 120 RPM, the relative error in time duration (or speed) was only $\epsilon = -0.004\%$, demonstrating excellent accuracy.


\begin{table}[h!]
  \centering
  \caption[Stability of PWM generation]{Stability of PWM generation}
  \begin{tabular}{| m{2cm} || m{2.5cm} | m{2.5cm} | m{2.5cm} | m{2.5cm} |}
    \hline
    RPM & $f_{\mathrm{desired}}$ (Hz) & $f_{\mathrm{low}}$ (Hz) & $f_{\mathrm{high}}$ (Hz) & $f_\mathrm{avg}$ (Hz) \\
    \hline
    10  & 33.334                      & 33.334                  & 33.334                   & 33.334                \\
    30  & 100                         & 100                     & 100.003                  & 100.002               \\
    60  & 200                         & 200                     & 200.01                   & 200.004               \\
    120 & 400                         & 400                     & 400.02                   & 400.007               \\
    \hline
  \end{tabular}
  \label{tab:performancepwm}
\end{table}

\begin{figure}[h!]
	\centering
	\includegraphics[width=0.7\textwidth]{../img/120rpm_to60_1.jpg}
	\includegraphics[width=0.7\textwidth]{../img/120rpm_to60_2.jpg}
	\caption[Moment of change between commands with 120RPM and 60RPM]{Moment of change between commands (120RPM $\Rightarrow$  60RPM)}
	\label{fig:switching}
\end{figure}

An attempt was made to also measure the delay  between switching commands, displayed in figure \ref{fig:switching}.
The results indicate that the delay between commands is imperceptible.
Similar outcomes were also observed for other command combinations.

This demonstrates the efficiency of the HAL layer in managing stepper motor control and transitioning seamlessly between commands.
As long as stepper queues are supplied with commands in advance, the platform can operate without noticeable interruptions.
Most importantly, the platform’s timely and predictable behavior ensures that mathematical corrections to the radar data can be applied accurately.



\chapter{Control application}

As previously stated on PC side whole radar is controlled using MALTAB application.
This application is split into two distinct parts - one is managing rotary platform and the other is processing radar data.
Alongside these there are some basic shared components, such as preferences.

\section{Main application interface}

Upon starting the application user is presented with the main window \ref{fig:main_window}.
Here output from radar is displayed, connection to platform and radar established and by clicking on the icons in top bar user can access other windows.
Preferences are hidden behind the paper icon, platform control interface behind the cube icon.

\begin{figure}[h!]
	\centering
	\includegraphics[width=0.9\textwidth]{../img/main_window.jpg}
	\caption[Main application window]{Main application window}
	\label{fig:main_window}
\end{figure}

\section{MATLAB Control Interface}

It is necessary to emphasizes that platform control is entirely independent of radar functions.
User loads up platform program, starts it execution and from that point while processing radar data only platform position is taken into account.
With current architecture there is no mechanism that would influence platform movement according to radar data.

Still as only one process can access platform serial interface at a time platform control is part of a larger program together with radar data processing.
The platform control is implemented in a simple MATLAB application that allows users to upload and manage programs on the microcontroller.
Along with the program management, the application also provides a simple interface for reading platform diagnostics and ability to configure some parameters.

From preferences menu \ref{fig:preferences_platform} user can configure serial port connection, introduce offset and set number of steps per revolution.
It is necessary to point out that number of steps must correspond to microstepping ratio used on the hardware.

\begin{figure}[h!]
	\centering
	\includegraphics[width=0.7\textwidth]{../img/platform_preferences.jpg}
	\caption[Platform related part of preferences menu]{Platform related part of preferences menu}
	\label{fig:preferences_platform}
\end{figure}

\begin{figure}[h!]
	\centering
	\includegraphics[width=0.9\textwidth]{../img/platform_control.jpg}
	\caption[GUI of the platform control]{GUI of the platform control}
	\label{fig:platformControl}
\end{figure}

Managing platform programs is done with separate window as shown in figure \ref{fig:platformControl}.
Here user can load, edit and send programs to the platform.
Also while programs send to the platform are not persistent, the application allows to save them locally alongside other configuration parameters.

Left sidebar allows user to load stored programs.
Middle windows is used to edit programs header (top part) and program body (bottom part).
Command used to denote start of program, end of header and so on are automatically sent to the device after program is saved and uploaded.
To validate whether program was parsed correctly user can consult the text window at the bottom of the screen which forwards platforms debug output to the user.

Backend side of platform control is rather straightforward forward.
After connection to platform is established MATLAB serial interface calls a callback each time terminator sequence is found in receiving data.
Received message is then parsed with debug output being forwarded to the user and positions logged with timestamp in a rotary buffer.
Radar data processing part can then request positions list in given time interval.

Platform control can also emit an event when specified yaw angle is reached.
Or to be more precise platform is withins ome interval of that positions.
This mechanism enables the program to clear stored radar data after each rotation.

\section{Radar Data Processing}

First it is neccesay to outline what are inputs and outputs of the whole processing pipeline.
Data used in processing come from two sources -- radar and platform.
These data are then processed according to users settings in preferences.
User can pick whether to calculate CFAR data, whether to keep raw radar cube data and in that case if speed calculation is needed.
Output is then stored in classical radar data cube \cite{richards2022} enabling integration of more advanced algorithms in the future.

As there are two possible distinct output there are two cubes used.
One is 4D structure with dimensions of fast time $\times$ slow time $\times$ yaw $\times$ pitch, this stores complete range doppler map for each spatial degree.
In this thesis this structure is only used for visualizing of raw data for given fixed pitch angle.
Second cube is 3D structure with dimensions of fast time $\times$ slow time $\times$ range and is used to store CFAR output.

Main complicating factor with radar data processing was the need to keep main thread responsive.
Most time critical aspect of this thread is timely reading of incoming serial data, be it from platform or radar.
As radar frames aren't timestamp slowdown in reading of them would lead to incorrect interpretation of the data in relation to platform position.
In addition GUI starts to be quite unresponsive if the resources of main thread are stretched too thin.

To solve this problem processing heavily leverages MATLAB's parallel computing toolbox, offloading as much as possible to different cores.
Through whole processing pipeline there are mechanism of buffering data into larger batches and if needed discarding some in case software is unable to keep up with incoming data.
We can split processing into three distinct components -- first part is reading data from serial, running basic FFT and storing them into buffer.
Second is running 2D FFT and CFAR on the data and them storing them into ping-pong buffer
And finally last part processes filled ping-pong buffer -- updating radar cube.

\begin{figure}[h!]
	\centering
  \begin{tikzpicture}[scale=0.9, node distance=1.5cm]

    % Layer headers
		\node (comm_layer) [layerheader] at (0, 0) {Serial Layer};
		\node (app_layer) [layerheader] at (6, 0) {CFAR/2D FFT Layer};
		\node (hal_layer) [layerheader] at (12, 0) {Cube update Layer};

    % Communication Layer
    \node (comm_start) [startstop, below of=comm_layer, yshift=-0.3cm] {Start};
		\node (wait_serial) [process, below of=comm_start] {(M) Wait for serial data};
    \node (notify_data) [process, below of=wait_serial] {(M) Notify data processor};
		\node (fft_calc) [process, below of=notify_data] {(M) Calculate FFT};
		\node (store_chirp) [process, below of=fft_calc, align=center] {Store data to buffer};

    % Arrows in Communication Layer
    \draw [arrow] (comm_start) -- (wait_serial);
    \draw [arrow] (wait_serial) -- (fft_calc);
    \draw [arrow] (fft_calc) -- (store_chirp);
    \draw [arrow] (store_chirp.west) -- ++(-0.5, 0) |- (wait_serial.west);

    % Application Layer
    \node (app_start) [startstop, below of=app_layer, yshift=-0.3cm] {Start};
    \node (update_position) [process, below of=app_start] {Update position};
    \node (check_queues) [decision, below of=update_position, yshift=-1.3cm] {Queues full?};
    \node (load) [process, below of=check_queues, align=center, yshift=-1.5cm] {Load command \\ queue ? program};
    \node (process_command) [process, below of=load,yshift=-0.25cm] {Process command};
    \node (store_command) [process, align=center, below of=process_command] {Add command \\ to stepper queue};

    % Arrows in Application Layer
    \draw [arrow] (app_start) -- (update_position);
    \draw [arrow] (update_position) -- (check_queues);
    \draw [arrow] (check_queues.east) -- ++(1, 0) |- (update_position.east) node[midway, left, xshift=0.2cm, yshift=+0.25cm,xshift=0.2cm] {Yes};
    \draw [arrow] (check_queues.south) -- ++(0, -0.5) -| (load.north) node[midway, right, yshift=+0.1cm] {No};
    \draw [arrow] (load.south) -- ++(0, -0.5) -- (process_command.north);
    \draw [arrow] (process_command) -- (store_command);
    \draw [arrow] (store_command.west) -- ++(-0.5, 0) |- (update_position.west);


    \node (hal_start) [startstop, below of=hal_layer, yshift=-0.3cm] {Start};
    \node (wait_queue) [process, below of=hal_start] {Wait on queue};
    \node (execute_command) [process, below of=wait_queue] {Execute command};
    \node (wait_command) [process, below of=execute_command] {Wait on command};
    \node (update_info) [process, align=center, below of=wait_command] {Update last \\command};

    % Arrows in HAL Layer
    \draw [arrow] (hal_start) -- (wait_queue);
    \draw [arrow] (wait_queue) -- (execute_command);
    \draw [arrow] (execute_command) -- (wait_command);
    \draw [arrow] (wait_command) -- (update_info);
    \draw [arrow] (update_info.west) -- ++(-0.5, 0) |- (wait_queue.west);

  \end{tikzpicture}

  \caption[Program flow diagram]{Program flow diagram}
  \label{fig:code_diag}
\end{figure}



\include{conclusion}

\include{bibliography}

\listoffigures

\listoftables

\clearpage
\openright
\end{document}

