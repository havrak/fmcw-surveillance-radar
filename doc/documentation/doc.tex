\def\PageLayout{single-no-print}
\def\DocLanguage{en}
\def\PackagesIncludeTikz{yes}
\def\PackagesIncludeBib{yes}

\input{dimensions_paper}
\input{packages}
\input{metadata}
\input{macros}
\input{xmp}
\input{doc_paper}

\addbibresource{bibliography.bib}

\newcommand{\sidar}{SiRad Easy\textsuperscript{\copyright} }
\newcommand{\boldred}[1]{\textbf{\textcolor{red}{#1}}}
\newcommand{\boldblue}[1]{\textbf{\textcolor{blue}{#1}}}
% \newcommand{\red}[1]{\textcolor{red}{#1}}


\begin{document}

\include{doc_paper_title_page_en}

\tableofcontents

\newpage
\pagenumbering{arabic}
\setcounter{page}{1}

\include{abbreviations}

\include{introduction}

\pagestyle{fancy}

\chapter{FMCW Radar Fundamentals}

\boldred{TODO: Consider some semi-introductory chapter before this one. Also the name "Basics of FMCW Radar" is not very good.}

As opposed to classical continuos wave (CW) radars Frequency Modulated Continuous Wave (FMCW) radars broadcast a signal not on a single frequency but with linear sweep across a range of frequencies.
Such approach allows computing a range estimation without requiring a pulsing signal.
This is while the capability to measure speed of the target using doppler shift is still maintained.
However the calculation of speed more complex than in case of broadcast on a single frequency.

The MW suffix in FMCW radar is used to denote that the radar operates in microwave range of frequencies.
Such frequencies enable the antenna array to be small, enabling even on chip internaration.
Also MM part of radio spectrum is generally license free \cite{spektrumCTU} and offers large bandwiths -- limiting possible interference.

\section{Comparison FMCW Radar to Pulse Radar}

Distance measurement with radar predates an invent of FMCW radar by a few decades.
Traditional approaches relied predominantly on sending pulsing the signal electromagnetic radiation and measuring time it takes for the signal to return.
On such radars speed can be calculated traditionally using Doppler effect as
\begin{equation}
	v = \frac{f_\mathrm{dop} c_o}{2f_\mathrm{rad}},
	\label{eq:dopler}
\end{equation}
where $f_\mathrm{dop}$ is doppler frequency, $c_o$ is speed of light and $f_\mathrm{rad}$ is frequency of the radar signal.
And distance was tied to time of flight $t$ of the signal as
\begin{equation}
	d = \frac{c_o \cdot t}{2}.
	\label{eq:distance}
\end{equation}

Such approach is on paper simpler and more intuitive however it has several drawbacks that seriously limit its precision and usability especially in close range applications.
In order to achieve a good resolution in distance measurement the pulse must be very short.
However in order to to impede on radars capabilities (need to maintain strong SNR over long distances) the power of the pulses must stay the same even when the duty cycle is dramatically increased \cite{jankiraman2018}.

Transmitting with high average power is problematic legally and technically.
It can result in interfering with other devices not to mention circuity to drive high power radars is bulky and expensive often requiring use of high voltages and vacuum tubes.
Thus pulsed radars are predominantly used in application where high resolution in range is not needed such as long range detection.

One major advantage of pulsed radar is the ease of processing data.
On FMCW radar the there is a entanglement of distance and speed readings as there is both frequency change due to Doppler effect and the frequency sweep itself.

\section{Basic principles of ideal FMCW radar}

Let us picture an ideal FMCW radar system sending a periodic chirp with frequency frequency sweep from $f_\mathrm{c}$ to $f_\mathrm{c}+BW$ so called sawtooth waveform.
This waveform is also used on the devkit used in this thesis \cite{sidarMAN}.

Other FMCW systems may use a different modulations such a linear triangular modulation or segmented linear frequency Modulation.
These offer some advantages but the nature  of the beat signal (which forms a sinewave with sawtooth modulation) is more complex in them especially when multiple targets are present \cite{jankiraman2018}.

\begin{figure}[h!]
	\centering
\begin{tikzpicture}[>=latex, scale=1]

% Axes
\draw[->] (0, 0) -- (8, 0) node[below] {$t$};
\draw[->] (0, 0) -- (0, 5) node[left] {$f$};

% Horizontal lines for BW
\draw[dashed] (0, 4.5) -- (7.5, 4.5);
\draw[dashed] (0, 1) -- (7.5, 1);
\draw[dashed] (2.5, -0.05) -- (2.5, 4.7);

% Labels for fc and BW
\node[left] at (0, 1) {$f_c$};
\draw[<->] (-0.5, 1) -- (-0.5, 4.5) node[midway,left] {$BW$};

% Triangular wave for Tx
\draw[thick,blue] (0, 1) -- (2.5, 4.5);
\draw[thick,blue]	(2.5, 1) -- (5, 4.5);
\draw[thick, dashed, blue] (5, 1) -- (6, 2.4);

% Triangular wave for Rx (offset version)
\draw[thick,red] (0.5, 1) -- (3, 4.5);
\draw[thick,red] (3, 1) -- (5.5, 4.5);
\draw[thick, dashed, red] (5.4, 1) -- (6.4, 2.4);

% Label for Tch
	\draw[-] (2.5, -0.05) -- (2.5, 0.05) node[below] {$T_{\text{ch}}$};

% Labels for Tx and Rx
\node[blue] at (4.2, 4.1) {\small Tx};
\node[red] at (5.3, 3.7) {\small Rx};

% Sweep slope and fb
\draw[<->] (1, 1) arc[start angle=0, end angle=55, radius=1];
\node at (1.5, 1.3) {\small $k_{\text{sw}}$};
\draw[<->] (1.5, 2.37) -- (1.5, 3.12) node[above, left] {$f_b$};

% Small time delay (tau)
\draw[<->] (2.5, 0.7) -- (3, 0.7) node[midway,below] {$\tau$};

\end{tikzpicture}

	\caption[Ideal relation of frequency and time for received and sent signal]{Ideal relation of frequency and time for received and sent signal}
	\label{fig:fmcw_ideal}
\end{figure}

We can clearly see that in given time $t$ the frequency spread from sent signal to received signal is proportional to the time delay $\tau$.
However doing some simple subtraction in spectrogram of the both signals isn't really feasible -- the calculation need to take a smarter approach.


Let us define the chirp slope $k_\mathrm{sw}$ we can describe the change in frequency of the received signal as
\begin{equation}
	\Delta f_\mathrm{s}(t) = k_\mathrm{sw}t = \frac{BW}{T_\mathrm{ch}} t,
	\label{eq:deltaf}
\end{equation}
where $t$ is the time goes from 0 to chirp length $T_\mathrm{ch}$. Standard equation of FM signal can be written as
\begin{equation}
	s_\mathrm{t}(t) = A \cos\left(\omega_c t + 2\pi \int_{0}^{t} f_\mathrm{s}(t) \mathrm{d}t\right),
	\label{eq:fm}
\end{equation}
where $A$ is amplitude of the signal, $\omega_c$ is carrier frequency and $f(s)$ is frequency of the signal. Substituting (\ref{eq:deltaf}) into (\ref{eq:fm}) we get the signal borrowed from the radar
\begin{equation}
	s_\mathrm{t}(t) = A \cos(\omega_c t + \pi k_\mathrm{sw}t^2).
	\label{eq:fm2}
\end{equation}

Signal bounced back from the target will have the same equation with the only difference being the time delay $\tau$,
\begin{equation}
	s_\mathrm{r}(t) = A \cos(\omega_c (t - \tau) + \pi k_\mathrm{sw}(t - \tau)^2).
	\label{eq:fm3}
\end{equation}
Now we can calculate the product of the two signals, this can be done easily in the real world using a frequency mixer. This is done with the standard formula $\cos(\alpha)\cos\beta = \frac{1}{2}(\cos(\alpha-\beta)+\cos(\alpha+\beta))$
The result of the multiplication is
\begin{align}
	s(t) = s_\mathrm{r}(t) \cdot  s_\mathrm{t}(t) &= \frac{A^2}{2}\cos\left(2(\omega_c - 2\pi k_\mathrm{sw}T_\tau)t + 2\pi k_{sw}t^2 + (\pi k_\mathrm{sw} \tau^2 - \omega_c \tau) \right)+ \nonumber \\
	&+\frac{A^2}{2} \cos\left(2\pi k_\mathrm{sw} \tau t + (\omega_c \tau - \pi k_\mathrm{sw} \tau^2)\right).
	\label{eq:fm4}
\end{align}
First additive term will lead to a signal with very high frequency, well above $2\omega_c$, this term doesn't carry any useful information and is usually filtered out -- either by low pass filter or the frequency mixer itself \cite{graham2005}.
Second term is so call beat signal whole frequency is directly proportional to the time delay $\tau$.
Applying a first time derivative to the cosine argument we get the frequency of the beat signal.
\begin{equation}
	f_\mathrm{b} = \frac{1}{2\pi}\frac{\partial}{\partial t} \left(2\pi k_\mathrm{sw} \tau t + (\omega_c \tau - \pi k_\mathrm{sw} \tau^2)\right) = k_\mathrm{sw} \tau.
	\label{eq:fb}
\end{equation}

Calculating the distance to the target is now trivial, delay $\tau$ is equal to the time it takes for the signal to travel to the target and back
\begin{equation}
	R = \frac{c_0 \tau}{2},
	\label{eq:distance2}
\end{equation}
By substituting (\ref{eq:fb}) into (\ref{eq:distance2}) we get an equation for distance
\begin{equation}
	R = \frac{c_0 f_\mathrm{b}}{2k_\mathrm{sw}}= \frac{c_o f_\mathrm{b} T_{\mathrm{ch}}}{2 BW}.
	\label{eq:distance3}
\end{equation}


\subsection{Limits of Range Measurement}

Absolute limit for maximal distance is given by the time it takes for the signal to travel from the radar to the target and back.
Would the distance be greater than a time of single chirp the signal would be interpreted as coming from a closer target.
That gives us an maximal limit on beat frequency $f_\mathrm{b} = BW$.

However in most case the limit will imposed not by $T_\mathrm{ch}$ respectively $BW$ but by our sampling frequency $f_\mathrm{s}$.
In order to avoid aliasing the Nyquist-Shannon theorem must be satisfied thus limiting the maximal beat frequency to $f_\mathrm{s}/2$ and giving us maximal distance of
\begin{equation}
	R = \frac{c_o f_\mathrm{s}}{4k_\mathrm{sw}}.
	\label{eq:distance4max}
\end{equation}

While sampling with frequency $f_\mathrm{s}$ we get $N =\mathrm{f}_\mathrm{s} T_\mathrm{ch}$ samples. Applying a Discrete Fourier Transform (DFT) to the signal we get $N$ samples in spectrum with frequency resolution of
\begin{equation}
	\upDelta f_\mathrm{b} = \frac{f_\mathrm{s}}{N} = \frac{1}{T_{ch}},
	\label{eq:resolution}
\end{equation}
we can see that the resolution of spectrum is only inversely proportional to the chirp length and doesn't have any relation to sampling frequency \cite{jankiraman2018}.
Now we can enter $\upDelta f_\mathrm{b}$ into (\ref{eq:distance3}) to get the minimal distance that can be measured as
\begin{equation}
	\upDelta R = \frac{c_o}{2BW}
	\label{eq:distance5min}
\end{equation}
Thus in order to increase resolution in range a wider bandwidth is needed.

There are of course other effect impeding the resolution of the radar system -- such a phase noise around targets or sweep nonlinearity.
Sweep Linearity can be both in the ramp itself -- leading to decreasing resolution with range (with both linear and quadratic errors present) \cite{graham2005} (Appendix D and E).
Or in sweep recovery (time to return to the start of the sweep) which leads to a fix decrease in resolution \cite{piper1995}.
Both are however largely compensated in modern radar systems by using a closed feedback loop \cite{graham2005}.


\subsection{Speed Measurement}

In order to demonstrate the effect of moving target on the beat frequency we can redefine the time delay $\tau$ as
\begin{equation}
	\tau = \frac{2(R_0+vt)}{c_o}
	\label{eq:tau}
\end{equation}
where $R_0$ is the initial distance to the target and $v$ is the radial speed of the target.
Within a single chirp there is no way to distinguish between the effects distance and speed of the target -- thus multiple chirps are needed.
Rewriting \label{eq:tau} as
\begin{equation}
	\tau = \frac{2(R_0 v(nT_\mathrm{ch} + t_\mathrm{s}))}{c_0}
	\label{eq:tau2}
\end{equation}
where $n$ is the number of chirps, $T_\mathrm{ch}$ is the chirp length and $t_\mathrm{s}$ denotes time withing  a single chirp ($0 \leq t_\mathrm{s} \leq T_\mathrm{ch}$).
Substituting (\ref{eq:tau2}) into low frequency part (\ref{eq:fm4}) leads to very complex equation, however according to \cite{suleymanov2016} most of the terms can be neglected leading us to
\begin{equation}
	s(t_\mathrm{s}, n) = \frac{A^2}{2} \cos\left(\frac{4\pi k_\mathrm{sw} R_0}{c_0} t_\mathrm{s} + \frac{2\omega_c v n}{c_0} T_\mathrm{ch} + \varphi_0 \right),
	\label{eq:fb2}
\end{equation}
where $\varphi_0$ is a phase shift given by the initial distance to the target.
Its clear that first element describes predominantly the distance to the target and the second one the speed of the target.
We can also see that speed will not affect a beat frequency in a single spectrum but will lead to a phase shift across multiple spectrums.

In order to calculate doppler shift frequency
\begin{equation}
	f_\mathrm{d} = \frac{2f_\mathrm{c}v}{c_0},
	\label{eq:doppler2}
\end{equation}
we can use 2D Fourier transform -- first in time within a single chirp and then in time across multiple chirps.
This will lead to a so called range-Doppler map which on one axis contains information about speed and on second distance of the target \cite{suleymanov2016}.

Speed resolution is derived from a number of chirps $N$ we are analyzing and their length $T_{\mathrm{ch}}$ as
\begin{equation}
	\upDelta v = \frac{c_0}{2f_c} \frac{1}{NT_{\mathrm{ch}}}.
	\label{eq:doppler3}
\end{equation}
On the other hand the increase in number of chirps will affect the distance measurement if the target movement speed is sufficiently high.



\chapter{\sidar}

Indie Semiconductor's \sidar is a FMCW radar system development kit designed primarily for automotive applications.
Out of the box it offsets two headers - a 24~GHz and 122~GHz one, both based on IC from Indie Semiconductors (TRX-024-007 and TRA-120-001 respectively).
Both are solely SISO systems thus by default azimut estimation is not possible.

\begin{figure}[h!]
	\centering
	\includegraphics[width=0.7\textwidth]{../img/sidar.png}

	\caption[\sidar \cite{sidarMANOld}]{\sidar  24~GHz configuration}
	\label{fig:sidar}
\end{figure}

Communication with the radar board itself isn't possible, or at least  the communication interface is not documented.
In order to configure the radar or read its measurements user is either connected to on board ESP chip via WiFi or to STM32 Nucleo series microcontroller over UART (facilitated with mini USB 2.0 connector).
Both are relatively low bandwidth communication -- the serial maxing at baudrate of 1~000~0000.

\begin{figure}[h!]
	\centering
	\includegraphics[width=0.7\textwidth]{../img/sidar_flow.png}
	\caption[Flow of Radar Measurement on \sidar \cite{sidarPRO}]{Flow of Radar Measurement on \sidar}
	\label{fig:sidarFlow}
\end{figure}

Devkit is designed to be as easy to integrate into existing project as possible this is unfortunately to the determent of this thesis.
In normal operating mode the radar system is a black box (Processing schema showed on \ref{fig:sidarFlow}) -- it's own filtering, FFT and CFAR algorithms and only reporting a target list to the user.
This whole sequence can be either triggered internally (driven by configurable oscillator) or externally (driven by GPIO pin or UART input).
After trigger is received the device will carry out a N chirps (or N+2 in case AGC is turned on) which are sampled with user chosen sampling frequency.
It is worth noting that as the computational abilities of the kit are rather restrictive radar might not emit a continuos sawtooth waveform but rather a segmented one \cite{sidarPRO}.

\section{Outline of Chosen Configuration }


For purpose of this project the driver was configured to output raw data from the 16 bit ADC in form of inphase and quadrature components of the signal.
This allows for a more detailed analysis of the radar system and the possibility of implementing custom signal processing algorithms.
For these reasons default windowing was also turned off.

In addition to picking ADC output there are many other necessary configuration steps that need to be taken in order to get a meaningful data from the radar for this application.
Chief among them is number of samples per chirp and number of chirps in a sequence.
Number of chirps will directly affect maximal distance that can be measured as (\ref{eq:distance4max}) demonstrates.
More important is the number of chirps within a set -- for moving platform its more beneficial to get smaller updates more often then to get a single large update.
If one needs it there is no problem to buffer multiple downlinks and process them as single large one.

Another parameter that warrants some consideration in rotary usecase is AGC.
Using it adds two additional ramps that are used solely to set gain value but it also can lead to inconsistent weights of values between two neighboring data sets.
Though the latter this is unlikely as the gain setting are quite far apart (8~dB$\Rightarrow$ 21~dB $\Rightarrow$ 43~dB as listed in \cite{sidarPRO}) so a difference in distance would have to be quite large.
Thus its safest to turn AGC off and set the gain manually depending on how the readings appear.

Its is also worth to point out that the radar system isn't really suited for changing configuration on the fly.
Configuration takes a quite a long time to be applied not to mention radar doesn't provide any feedback that would enable user to send new configuration at the right time.
Thus commonly used techniques such as alternating chirp slope or frequency are not possible.


\boldred{TODO: compare TSV output vs binary output}








\section{24~GHz Header}

Center of 24~GHz header is a SISO TRX-024-007 transceiver which integrates low noise amplifier, frequency mixer, filters and VCO into a single chip.
It's designed to broadcast primarily in the ISM band (24.0-24.25~GHz) additionally ultra-wide bandwidth mode is also supported (23-26~GHz) \cite{sidarTRX24} however this mode cannot be enabled on the development kit \cite{sidarPRO}.
In its main band transmitter output power is in the range of 2.5-6~dBm depending on the configuration \cite{sidarTRX24}.
Maximal range of 400~m is advertised \cite{sidarMANOld}, however this is likely under ideal conditions when observing a large target.

As showed on picture \ref{fig:sidar} the chip is connected to two microstrip patch antennas.
Patches are placed in relatively standard configuration forming a 6 by 4 array with spacing roughly equal to half of the wavelength at 24~GHz.

Since the manufacturer doesn't provide any information about the radiation pattern of the array a simulation was carried out using CST simulation suite.
%% Dimensions of the array were taken using a classical optical microscope and whole array was redrawn \ref{fig:24drawing} in CST studio. TODO
Substrate parameters also weren't provided by the manufacturer for the radar board specifically.
Thankfully in the TRX-024-007 datasheet there is a board stack up for the evalutions board for the chip itself.
It was assumed that same stack up would be used -- 18~$\mu$m copper for the traces and grounding plane with 250~$\mu$m thick substrate of Rogers RO4350B \cite{sidarTRX24}.

Radar board showed a smallest reflection coefficient $s_{11} = -25\mathrm{~dB}$ at 24.5~GHz.
This could be explained by difficulties in measuring exact dimensions (Etching quality of the copper tracer wasn't the greatest.) and neglecting change of substrate parameters due to interactions of different layers.

\section{122~GHz Header}

\begin{figure}[h!]
	\centering
	\includegraphics[width=0.7\textwidth]{../img/sidar122.png}
	\caption[\sidar with 122~GHz header \cite{sidarPRO}]{\sidar with 122~GHz header}
	\label{fig:sidar122}
\end{figure}

122~GHz header is based on TRX-120-001 transceiver that aside from basic components needed to transmit and receive RF also include two on-chip antennas.
It's designed to operate in the 122-123~GHz band and with output power ranging from -7~dBm to 1~dBm \cite{sidarTRX122}.
Out of the box performance of the system is quite bad (see \ref{fig:sidar122rad}) with width of the main lobe being roughly $\pm40\text{°}$ in both E-plane and H-plane \cite{sidarTRX122}.
This can be improved by supplied collimator lens to $\pm4\text{°}$ \cite{sidarTRX122col} (see \ref{fig:sidar122radcol}).
The chip can detect large targets up to 40~m away \cite{sidarMANOld}.


\begin{figure}[h!]
	\centering
	\includegraphics[width=0.7\textwidth]{../img/sidar122rad.jpg}
	\caption[Radiation pattern of 122~GHz header comparison \cite{sidarTRX122col}]{Radiation pattern of 122~GHz header comparison}
	\label{fig:sidar122rad}
\end{figure}


\chapter{Rotary Platform}

Following chapter outlines design process and operation of a rotary platform specifically designed for \sidar radar system.

\section{Platform Design Parameters}


To begin, it is essential to outline the fundamental requirements for the platform.
These stem from the physical capabilities of the radar system, SiRad Easy evalutions kit, and requirements for the software.

\subsection{Physical Capabilities}

The primary constraints on the physical design arise from the radar's radiation pattern (Both 24 and 122 GHz headers are accounted for.).
That gives us information about the clearance needed in front of the radar and more importantly how precise the platform needs to be.
As stated previously the 24~GHz radar has a main lobe width of some $\pm7\text{°}$ and the 122~GHz radar has a main lobe width of $\pm4\text{°}$ \cite{sidarTRX122}.
Thus a conservative clearance of $\pm45\text{°}$ in front of the radar was set in order to prevent any strong reflections be it from the main lobe or side lobes.

With a relatively low angular resolution of the radar a high precision of the platform is not needed.
Basic 200 step stepper motor with step size of 1.8\text{°} is sufficient however smoother motion will be easier to compensate for in the software.
Still due to low radar weight, measured at 120~g with the mounting bracket, the smoothens of the motion can be achieved relying solely on microstepping of the motor.

In terms of speed, due to the radar system's relatively low polling rate (1 Mbit/s \cite{sidarMAN}), high-speed movement is unnecessary. The manufacturer specifies a maximum update frequency of 50 Hz, equating to a new update every 20 ms \cite{sidarMAN}.
Using the following equation:
%
\begin{equation}
  t_{\mathrm{angle}} = \frac{60}{360\cdot N_{\mathrm{RMP}}} \cdot  \alpha,
  \label{eq:poll}
\end{equation}
%
where $t_{\mathrm{angle}}$ is time between spend on traveling angle of $\alpha $ in seconds and $N_{\mathrm{RMP}}$ is number of rotations per minute, we can calculate that even for low RPM of 60 an angle of 8 degrees the platform travels (angular width of main lobe for 122 GHz radar) in 10 ms.

\subsection{Software Requirements}

Given its widespread adoption as an industry standard for controlling multi-axis machines, G-code over serial is a natural choice for the platform's communication format. Beyond the basic functionality typically offered by G-code interpreters, the platform must support additional features to reduce the user's manual control burden. These features include the ability to define movement limits and preprogram sequences of movements for autonomous execution by the platform.

For uplink communication, the platform must provide real-time information about its current position and speed. This data allows the user to make mathematical corrections to the radar's gathered data.


\section{Platform Construction}

\boldred{TODO: Add more pictures, list out dimensions, little bit more info about 3D print.}

To enable continuous rotational motion, the use of a slip ring is indispensable. Given the radar system's relatively low transmission speed, a standard contact slip ring suffices -- a model with a USB 2.0 interface and eight additional lines was selected to meet the system's needs. The rest of the structure is 3D printed from PLA, since mechanical stresses on the platform are minimal.


\begin{figure}[h!]
  \centering
  \begin{subfigure}[b]{0.45\textwidth}
    \centering
    \includegraphics[width=\textwidth]{../img/whole_assembly_2.png} % Replace with your image path
    \caption{3D render}
  \end{subfigure}
  \hspace{0.05\textwidth} % Adjust spacing
  \begin{subfigure}[b]{0.45\textwidth}
    \centering
    \includegraphics[width=0.75\textwidth]{../img/assembly_photo.jpg} % Replace with your image path
    \caption{Photo}
  \end{subfigure}
  \caption{Form of the final assembly}
  \label{fig:side_by_side}
\end{figure}

In stark departure from commercial solutions \cite{carl,standa} due to need to accommodate a large slipring first axis controls rotation and second one tilt.
This arrangement also leads to simpler calculation of speed vector, needed for radar processing, by reducing the interdependence of movements between each axis.


\subsection{Platform Electronics}

\boldred{
	TODO: total rewrite of this section, drop things about Hall effect, outlay a basic schema of what components are present and how are they connected.
	Keep it rather short if possible
}

% \red{
Electronic side of the project is rather simple given that only control of two stepper motors and having ability to home their position is needed.
The system is managed by an ESP32 microcontroller. Since the project does not demand advanced capabilities, a basic ESP32 model is sufficient.

Given the low load on stepper motors and the platform's inability to accumulate significant momentum, a simple stepper driver without feedback control is adequate.
For this purpose, the A4988 stepper driver was selected, due to its low cost, microstepping capabilities and basic current control \cite{a4988}.

To implement homing, two potential solutions were considered: Hall effect sensors and optical gates.
While Hall effect sensors offer the advantage of angle sensing, allowing correction of any positional drift during operation, they require precise alignment.
If the orthogonal Hall effect sensor is not perfectly placed in the axis of rotation, non simply calibration becomes a necessity \cite{hall}.

Thus for simplicity and ease of integration, optical gates were selected.
This decision eliminates the need for complex calibration while providing reliable functionality.
% }

\section{Platform Software Realization}

\boldblue{NOTE: Basic structure of this chapter is fine.}

To maximize efficiency in processing commands and ensure accurate stepper motor control, the program workflow is divided into three distinct layers, as illustrated by figure \ref{fig:code_diag}.

The commonly used two-component architecture—where one component handles communication/command parsing and the other manages execution—was deemed unsuitable for this use case.
Such an approach would complicate integration of programming interface and require just-in-time processing of commands, which could lead to performance issues.

In the chosen architecture, the degree of abstraction decreases with each successive layer, simplifying processing at each step.
This design allows the final layer to operate with maximum efficiency, where transition from one command to the next is primarily limited by the inertia of stepper motors and not by the software.

\begin{figure}[h!]
  \centering


  \begin{tikzpicture}[scale=0.9, node distance=1.5cm]

    % Layer headers
    \node (comm_layer) [layerheader] at (0, 0) {Communication Layer};
    \node (app_layer) [layerheader] at (6, 0) {Application Layer};
    \node (hal_layer) [layerheader] at (12, 0) {HAL Layer};

    % Communication Layer
    \node (comm_start) [startstop, below of=comm_layer, yshift=-0.3cm] {Start};
    \node (wait_serial) [process, below of=comm_start] {Wait for serial data};
    \node (parse_gcode) [process, below of=wait_serial] {Parse G-code};
    \node (parse_success) [decision, below of=parse_gcode, align=center, yshift=-1.3cm] {Parsing\\ Successful?};
    \node (store_command) [process, below of=parse_success, align=center, yshift=-1.8cm] {Store command\\ queue ? program};
    \node (send_response) [process, below of=store_command,yshift=-0.25cm] {Send response};

    % Arrows in Communication Layer
    \draw [arrow] (comm_start) -- (wait_serial);
    \draw [arrow] (wait_serial) -- (parse_gcode);
    \draw [arrow] (parse_gcode) -- (parse_success);
    \draw [arrow] (parse_success.east) -- ++(1, 0) |- (send_response.east) node[midway, left, yshift=+0.25cm] {No};
    \draw [arrow] (parse_success.south) -- ++(0, -0.5) -| (store_command.north) node[midway, right, yshift=+0.05cm] {Yes};
    \draw [arrow] (store_command) -- (send_response);
    \draw [arrow] (send_response.west) -- ++(-0.5, 0) |- (wait_serial.west);

    % Application Layer
    \node (app_start) [startstop, below of=app_layer, yshift=-0.3cm] {Start};
    \node (update_position) [process, below of=app_start] {Update position};
    \node (check_queues) [decision, below of=update_position, yshift=-1.3cm] {Queues full?};
    \node (load) [process, below of=check_queues, align=center, yshift=-1.5cm] {Load command \\ queue ? program};
    \node (process_command) [process, below of=load,yshift=-0.25cm] {Process command};
    \node (store_command) [process, align=center, below of=process_command] {Add command \\ to stepper queue};

    % Arrows in Application Layer
    \draw [arrow] (app_start) -- (update_position);
    \draw [arrow] (update_position) -- (check_queues);
    \draw [arrow] (check_queues.east) -- ++(1, 0) |- (update_position.east) node[midway, left, xshift=0.2cm, yshift=+0.25cm,xshift=0.2cm] {Yes};
    \draw [arrow] (check_queues.south) -- ++(0, -0.5) -| (load.north) node[midway, right, yshift=+0.1cm] {No};
    \draw [arrow] (load.south) -- ++(0, -0.5) -- (process_command.north);
    \draw [arrow] (process_command) -- (store_command);
    \draw [arrow] (store_command.west) -- ++(-0.5, 0) |- (update_position.west);


    \node (hal_start) [startstop, below of=hal_layer, yshift=-0.3cm] {Start};
    \node (wait_queue) [process, below of=hal_start] {Wait on queue};
    \node (execute_command) [process, below of=wait_queue] {Execute command};
    \node (wait_command) [process, below of=execute_command] {Wait on command};
    \node (update_info) [process, align=center, below of=wait_command] {Update last \\command};

    % Arrows in HAL Layer
    \draw [arrow] (hal_start) -- (wait_queue);
    \draw [arrow] (wait_queue) -- (execute_command);
    \draw [arrow] (execute_command) -- (wait_command);
    \draw [arrow] (wait_command) -- (update_info);
    \draw [arrow] (update_info.west) -- ++(-0.5, 0) |- (wait_queue.west);

  \end{tikzpicture}

  \caption[Programm diagram]{Programm diagram}
  \label{fig:code_diag}
\end{figure}

\subsection{Communication layer}

The communication layer manages incoming data over the serial line, with efficient handling facilitated with the aid of RTOS queues.
Upon receiving data the text string is parsed and either pushed to a queue or added to programm declaration, in case we are currently declaring program.

Immediately after parsing, a response is send to the user confirming whether the command was parsed correctly or not.
However, as the communication layer does not a can not check command within context of all previous commands, it is possible that command will be parsed correctly but its execution will fail in the application layer.


\subsection{Application layer}

The application layer performs two primary functions: tracking the current device position and scheduling commands to be sent to stepper motors.
Aside from current position the program also keeps track of the end position of the last scheduled command.
Thanks to this the application layer make necessary calculations to facilitate absolute positioning and enforce movement limits.

A key departure from standard G-code interpreters, like \cite{duet}, is how the platform handles single-axis move commands.
When a move command targets only one axis, the other axis remains free to read next command and begin its execution.
If this behavior is undesirable, the user must issue commands for both axes.
In relative positioning mode, a zero value results in no motion; in absolute positioning mode, the command must specify the current position to prevent movement.

This behavior is a necessary side effect of the spindle regime, which typically cannot be toggled on or off dynamically.
Another consequence is the requirement for separate positioning modes for each axis.
Continuous rotation prevents calculations of a move’s end position, making it impossible to make calculation for absolute positioning commands -- thus necessitating relative positioning.
However it would be rather restrictive to force user to relative positioning on second axis, therefore the independent positioning settings.




\subsection{HAL Layer}

\boldred{TODO: Drop primitive equation which is totaly unnecessary and was only included to comply with the original assigment}

The final layer manages stepper motor control and provides the application layer with essential data for position calculations.
In its loop, the program waits for the next command in the stepper queue.
Upon receiving a command, it sets up execution, waits for one or both steppers to complete their movement, and then proceeds to the next command.
Since limit and absolute positioning calculations are handled in the application layer whole routine remains highly efficient.

The main challenge lies in generating precise PWM signals (Used to control stepper motors drivers.) and stopping signal generation after a specific number of steps.
Using the equation:
%
\begin{equation}
  t_{\mathrm{delay}}(s) = \frac{60}{2\cdot N_{\mathrm{steps}} \cdot s},
  \label{eq:delay}
\end{equation}
%
where $s$ is speed in RPM, $N_{\mathrm{steps}}$ is the number of steps (Anywhere from 200 to 1600 depending on microstepping.), and $t_{\mathrm{delay}}$ is the time between steps, we calculate that even at 30 RPM, the delay between output changes is 5 ms per step.
With microstepping at a 2:1 ratio, this reduces to 2.5 ms -- faster than lowest sleep interval on ESP32 and without sleeping the RTOS watchdog will trigger.
Therefore, signal generation must leverage specialized microcontroller peripherals.

The ESP32 platform offers two options: Remote Controlled Transceiver (RMT) and Motor Control Pulse Width Modulation (MCPWM) combined with Pulse Counter (PCNT).
While RMT allows smooth PWM frequency adjustments, it has several drawbacks.
Such as the fact that generating a specific number of pulses is supported only on newer ESP32 models \cite{gitRMT}, synchronization is restricted to its proprietary API, and there is no straightforward way to track progress during a move \cite{espRMT}.

For these reasons, MCPWM and PCNT were chosen.
MCPWM handles pulse generation, while PCNT counts steps, enabling easy synchronization, continuous rotation, and a robust API for step tracking \cite{espPCNT}.
The only limitation is the PCNT’s 15-bit counter, which caps the maximum steps per move at 32.767.


\subsubsection{Performance of the HAL Layer}

\boldred{TODO: Including Measurement is not a bad idea however the table is totaly redundant and doesn't provide much.}

Table \ref{tab:performancepwm} illustrates the stability of PWM generation by the MCPWM module at various speeds.
Measurements were conducted using a Saleae Logic Pro 16 logic analyzer, with no microstepping enabled.

The results show that frequency deviation is minimal, though the generated speed is consistently marginally faster than the target, and  the error increases slightly with higher speeds.
Nevertheless, when measuring time of 24,000 steps at 120 RPM, the relative error in time duration (or speed) was only $\epsilon = -0.004\%$, demonstrating excellent accuracy.


\begin{table}[h!]
  \centering
  \caption[Stability of PWM generation]{Stability of PWM generation}
  \begin{tabular}{| m{2cm} || m{2.5cm} | m{2.5cm} | m{2.5cm} | m{2.5cm} |}
    \hline
    RPM & $f_{\mathrm{desired}}$ (Hz) & $f_{\mathrm{low}}$ (Hz) & $f_{\mathrm{high}}$ (Hz) & $f_\mathrm{avg}$ (Hz) \\
    \hline
    10  & 33.334                      & 33.334                  & 33.334                   & 33.334                \\
    30  & 100                         & 100                     & 100.003                  & 100.002               \\
    60  & 200                         & 200                     & 200.01                   & 200.004               \\
    120 & 400                         & 400                     & 400.02                   & 400.007               \\
    \hline
  \end{tabular}
  \label{tab:performancepwm}
\end{table}

\begin{figure}[h!]
	\centering
	\includegraphics[width=0.7\textwidth]{../img/120rpm_to60_1.jpg}
	\includegraphics[width=0.7\textwidth]{../img/120rpm_to60_2.jpg}
	\caption[Moment of change between commands with 120RPM and 60RPM]{Moment of change between commands (120RPM $\Rightarrow$  60RPM)}
	\label{fig:switching}
\end{figure}

An attempt was made to also measure the delay  between switching commands, displayed in figure \ref{fig:switching}.
The results indicate that the delay between commands is imperceptible.
Similar outcomes were also observed for other command combinations.

This demonstrates the efficiency of the HAL layer in managing stepper motor control and transitioning seamlessly between commands.
As long as stepper queues are supplied with commands in advance, the platform can operate without noticeable interruptions.
Most importantly, the platform’s timely and predictable behavior ensures that mathematical corrections to the radar data can be applied accurately.

\chapter{Radar Data Processing}

\boldred{TODO: target detection at least using CFAR}

\include{conclusion}

\include{bibliography}

\listoffigures

\listoftables

\clearpage
\openright
\end{document}
